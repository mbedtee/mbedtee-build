diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/Config.in buildroot/Config.in
--- buildroot-ori/Config.in	2025-10-08 11:12:36.476702872 +0800
+++ buildroot/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -1015,6 +1015,8 @@ source "system/Config.in"
 
 source "linux/Config.in"
 
+source "tee/Config.in"
+
 source "package/Config.in"
 
 source "fs/Config.in"
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_ast2600_defconfig buildroot/configs/mbedtee_qemu_ast2600_defconfig
--- buildroot-ori/configs/mbedtee_qemu_ast2600_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_ast2600_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,46 @@
+BR2_arm=y
+BR2_cortex_a7=y
+BR2_ARM_FPU_VFPV3D16=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_ARMV7_EABIHF_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-ast2600-cortex-a7x2"
+BR2_TARGET_GENERIC_ISSUE="arm @ QEMU AST2600"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv7a_qemu_ast2600_linux_config"
+BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y
+BR2_LINUX_KERNEL_IMAGE_TARGET_NAME="Image"
+BR2_LINUX_KERNEL_IMAGE_NAME="Image"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_ast2600"
+BR2_PLATFORM_CFG="qemu_ast2600_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_ast2700_defconfig buildroot/configs/mbedtee_qemu_ast2700_defconfig
--- buildroot-ori/configs/mbedtee_qemu_ast2700_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_ast2700_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a35=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-ast2700-cortex-a35x4"
+BR2_TARGET_GENERIC_ISSUE="aarch64 @ QEMU-AST2700"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_qemu_ast2700_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_ast2700"
+BR2_PLATFORM_CFG="qemu_ast2700_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_imx7d_defconfig buildroot/configs/mbedtee_qemu_imx7d_defconfig
--- buildroot-ori/configs/mbedtee_qemu_imx7d_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_imx7d_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,46 @@
+BR2_arm=y
+BR2_cortex_a7=y
+BR2_ARM_FPU_VFPV3D16=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_ARMV7_EABIHF_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-imx7d"
+BR2_TARGET_GENERIC_ISSUE="aarch32 @ qemu-imx7d"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv7a_qemu_imx7d_linux_config"
+BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y
+BR2_LINUX_KERNEL_IMAGE_TARGET_NAME="Image"
+BR2_LINUX_KERNEL_IMAGE_NAME="Image"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_imx7d"
+BR2_PLATFORM_CFG="qemu_imx7d_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_malta_mips32r2_defconfig buildroot/configs/mbedtee_qemu_malta_mips32r2_defconfig
--- buildroot-ori/configs/mbedtee_qemu_malta_mips32r2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_malta_mips32r2_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,36 @@
+BR2_mipsel=y
+BR2_mips_32r2=y
+BR2_TOOLCHAIN_BUILDROOT_UCLIBC=y
+BR2_KERNEL_HEADERS_6_6=y
+BR2_TOOLCHAIN_BUILDROOT_USE_SSP=y
+# BR2_UCLIBC_INSTALL_UTILS is not set
+BR2_GCC_VERSION_14_X=y
+BR2_TOOLCHAIN_BUILDROOT_CXX=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_JLEVEL=32
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="malta_mips32r2"
+BR2_TARGET_GENERIC_ISSUE="runs on malta mips32r2"
+BR2_INIT_NONE=y
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_malta_mips32r2"
+BR2_PLATFORM_CFG="qemu_malta_mips32r2_defconfig"
+# BR2_PACKAGE_BUSYBOX is not set
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_raspi4b_defconfig buildroot/configs/mbedtee_qemu_raspi4b_defconfig
--- buildroot-ori/configs/mbedtee_qemu_raspi4b_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_raspi4b_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a72=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-raspi4b"
+BR2_TARGET_GENERIC_ISSUE="raspi4b @ QEMU"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_qemu_raspi4b_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_raspi4b"
+BR2_PLATFORM_CFG="qemu_raspi4b_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_sifive_u_riscv32_defconfig buildroot/configs/mbedtee_qemu_sifive_u_riscv32_defconfig
--- buildroot-ori/configs/mbedtee_qemu_sifive_u_riscv32_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_sifive_u_riscv32_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,32 @@
+BR2_riscv=y
+BR2_RISCV_32=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="sifive_u_riscv32"
+BR2_TARGET_GENERIC_ISSUE="runs on qemu-sifive-u-riscv32"
+BR2_INIT_NONE=y
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_sifive_u_riscv32"
+BR2_PLATFORM_CFG="qemu_sifive_u_riscv32_defconfig"
+# BR2_PACKAGE_BUSYBOX is not set
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+# BR2_PACKAGE_HOST_ARM_GNU_TOOLCHAIN_SUPPORTS is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_sifive_u_riscv64_defconfig buildroot/configs/mbedtee_qemu_sifive_u_riscv64_defconfig
--- buildroot-ori/configs/mbedtee_qemu_sifive_u_riscv64_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_sifive_u_riscv64_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,32 @@
+BR2_riscv=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_JLEVEL=32
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="sifive_u_riscv64"
+BR2_TARGET_GENERIC_ISSUE="runs on qemu-sifive-u-riscv64"
+BR2_INIT_NONE=y
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_sifive_u_riscv64"
+BR2_PLATFORM_CFG="qemu_sifive_u_riscv64_defconfig"
+# BR2_PACKAGE_BUSYBOX is not set
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+# BR2_PACKAGE_HOST_ARM_GNU_TOOLCHAIN_SUPPORTS is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_virt_aarch64_defconfig buildroot/configs/mbedtee_qemu_virt_aarch64_defconfig
--- buildroot-ori/configs/mbedtee_qemu_virt_aarch64_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_virt_aarch64_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a75=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-virt-aarch64"
+BR2_TARGET_GENERIC_ISSUE="aarch64 @ QEMU"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_qemu_virt_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_virt_aarch64"
+BR2_PLATFORM_CFG="qemu_virt_aarch64_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_virt_arm_defconfig buildroot/configs/mbedtee_qemu_virt_arm_defconfig
--- buildroot-ori/configs/mbedtee_qemu_virt_arm_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_virt_arm_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,46 @@
+BR2_arm=y
+BR2_cortex_a15=y
+BR2_ARM_FPU_VFPV3D16=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_ARMV7_EABIHF_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-virt-aarch32"
+BR2_TARGET_GENERIC_ISSUE="arm @ QEMU virt aarch32"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv7a_qemu_virt_linux_config"
+BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y
+BR2_LINUX_KERNEL_IMAGE_TARGET_NAME="Image"
+BR2_LINUX_KERNEL_IMAGE_NAME="Image"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_virt_arm"
+BR2_PLATFORM_CFG="qemu_virt_arm_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_virt_riscv32_defconfig buildroot/configs/mbedtee_qemu_virt_riscv32_defconfig
--- buildroot-ori/configs/mbedtee_qemu_virt_riscv32_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_virt_riscv32_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,32 @@
+BR2_riscv=y
+BR2_RISCV_32=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="riscv32"
+BR2_TARGET_GENERIC_ISSUE="runs on qemu-virt-riscv32"
+BR2_INIT_NONE=y
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_virt_riscv32"
+BR2_PLATFORM_CFG="qemu_virt_riscv32_defconfig"
+# BR2_PACKAGE_BUSYBOX is not set
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+# BR2_PACKAGE_HOST_ARM_GNU_TOOLCHAIN_SUPPORTS is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_virt_riscv32_linux_defconfig buildroot/configs/mbedtee_qemu_virt_riscv32_linux_defconfig
--- buildroot-ori/configs/mbedtee_qemu_virt_riscv32_linux_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_virt_riscv32_linux_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,46 @@
+BR2_riscv=y
+BR2_RISCV_32=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_RISCV32_ILP32D_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="riscv32"
+BR2_TARGET_GENERIC_ISSUE="runs on qemu-virt-riscv32"
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/riscv32_qemu_virt_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_virt_riscv32"
+BR2_PLATFORM_CFG="qemu_virt_riscv32_with_ree_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_TARGET_OPENSBI=y
+BR2_TARGET_OPENSBI_CUSTOM_VERSION=y
+BR2_TARGET_OPENSBI_CUSTOM_VERSION_VALUE="1.7"
+BR2_TARGET_OPENSBI_PLAT="generic"
+# BR2_TARGET_OPENSBI_INSTALL_DYNAMIC_IMG is not set
+BR2_TARGET_OPENSBI_LINUX_PAYLOAD=y
+BR2_TARGET_OPENSBI_ADDITIONAL_VARIABLES="FW_TEXT_START=0x86000000 FW_FDT_PATH=${BINARIES_DIR}/linux.dtb"
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_virt_riscv64_defconfig buildroot/configs/mbedtee_qemu_virt_riscv64_defconfig
--- buildroot-ori/configs/mbedtee_qemu_virt_riscv64_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_virt_riscv64_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,32 @@
+BR2_riscv=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_JLEVEL=32
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="riscv64"
+BR2_TARGET_GENERIC_ISSUE="runs on qemu-virt-riscv64"
+BR2_INIT_NONE=y
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_virt_riscv64"
+BR2_PLATFORM_CFG="qemu_virt_riscv64_defconfig"
+# BR2_PACKAGE_BUSYBOX is not set
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+# BR2_PACKAGE_HOST_ARM_GNU_TOOLCHAIN_SUPPORTS is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_virt_riscv64_linux_defconfig buildroot/configs/mbedtee_qemu_virt_riscv64_linux_defconfig
--- buildroot-ori/configs/mbedtee_qemu_virt_riscv64_linux_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_virt_riscv64_linux_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,45 @@
+BR2_riscv=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_RISCV64_LP64D_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="riscv64"
+BR2_TARGET_GENERIC_ISSUE="runs on qemu-virt-riscv64"
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/riscv64_qemu_virt_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_virt_riscv64"
+BR2_PLATFORM_CFG="qemu_virt_riscv64_with_ree_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_TARGET_OPENSBI=y
+BR2_TARGET_OPENSBI_CUSTOM_VERSION=y
+BR2_TARGET_OPENSBI_CUSTOM_VERSION_VALUE="1.7"
+BR2_TARGET_OPENSBI_PLAT="generic"
+# BR2_TARGET_OPENSBI_INSTALL_DYNAMIC_IMG is not set
+BR2_TARGET_OPENSBI_LINUX_PAYLOAD=y
+BR2_TARGET_OPENSBI_ADDITIONAL_VARIABLES="FW_TEXT_START=0x86000000 FW_FDT_PATH=${BINARIES_DIR}/linux.dtb"
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_xlnx_versal_virt_defconfig buildroot/configs/mbedtee_qemu_xlnx_versal_virt_defconfig
--- buildroot-ori/configs/mbedtee_qemu_xlnx_versal_virt_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_xlnx_versal_virt_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a72=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-xlnx-versal-virt"
+BR2_TARGET_GENERIC_ISSUE="xlnx-versal-virt @ QEMU"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_qemu_xlnx_versal_virt_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_xlnx_versal_virt"
+BR2_PLATFORM_CFG="qemu_xlnx_versal_virt_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_qemu_xlnx_zcu102_defconfig buildroot/configs/mbedtee_qemu_xlnx_zcu102_defconfig
--- buildroot-ori/configs/mbedtee_qemu_xlnx_zcu102_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_qemu_xlnx_zcu102_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a72=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="qemu-xlnx-zcu102"
+BR2_TARGET_GENERIC_ISSUE="xlnx-zcu102 @ QEMU"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_qemu_xlnx_zcu102_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="qemu_xlnx_zcu102"
+BR2_PLATFORM_CFG="qemu_xlnx_zcu102_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_salix_soc_mips74k_defconfig buildroot/configs/mbedtee_salix_soc_mips74k_defconfig
--- buildroot-ori/configs/mbedtee_salix_soc_mips74k_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_salix_soc_mips74k_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,34 @@
+BR2_mipsel=y
+BR2_mips_32r2=y
+BR2_KERNEL_HEADERS_6_6=y
+BR2_GCC_VERSION_14_X=y
+BR2_TOOLCHAIN_BUILDROOT_CXX=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_JLEVEL=32
+BR2_OPTIMIZE_1=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="mips32r2"
+BR2_TARGET_GENERIC_ISSUE="runs on mips74k"
+BR2_INIT_NONE=y
+# BR2_TARGET_ENABLE_ROOT_LOGIN is not set
+# BR2_TARGET_GENERIC_GETTY is not set
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="salix_mips74k"
+BR2_PLATFORM_CFG="salix_soc_mips74k_defconfig"
+# BR2_PACKAGE_BUSYBOX is not set
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca15_defconfig buildroot/configs/mbedtee_vexpress_ca15_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca15_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca15_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,46 @@
+BR2_arm=y
+BR2_cortex_a15=y
+BR2_ARM_FPU_VFPV3D16=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_ARMV7_EABIHF_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-arm"
+BR2_TARGET_GENERIC_ISSUE="arm @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv7a_vexpress_ca15_linux_config"
+BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y
+BR2_LINUX_KERNEL_IMAGE_TARGET_NAME="Image"
+BR2_LINUX_KERNEL_IMAGE_NAME="Image"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca15"
+BR2_PLATFORM_CFG="vexpress_ca15_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca17x4_ca7x4_defconfig buildroot/configs/mbedtee_vexpress_ca17x4_ca7x4_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca17x4_ca7x4_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca17x4_ca7x4_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,46 @@
+BR2_arm=y
+BR2_cortex_a17_a7=y
+BR2_ARM_FPU_VFPV3D16=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_ARMV7_EABIHF_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-arm-big.LITTLE"
+BR2_TARGET_GENERIC_ISSUE="arm-big.LITTLE @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv7a_vexpress_ca15_linux_config"
+BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y
+BR2_LINUX_KERNEL_IMAGE_TARGET_NAME="Image"
+BR2_LINUX_KERNEL_IMAGE_NAME="Image"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca17x4_ca7x4"
+BR2_PLATFORM_CFG="vexpress_ca17x4_ca7x4_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca510x4_ca710x4_defconfig buildroot/configs/mbedtee_vexpress_ca510x4_ca710x4_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca510x4_ca710x4_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca510x4_ca710x4_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a75_a55=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-aarch64-big.LITTLE"
+BR2_TARGET_GENERIC_ISSUE="aarch64 big.LITTLE @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_vexpress_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca510x4_ca710x4"
+BR2_PLATFORM_CFG="vexpress_ca510x4_ca710x4_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca53_defconfig buildroot/configs/mbedtee_vexpress_ca53_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca53_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca53_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,41 @@
+BR2_aarch64=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-aarch64"
+BR2_TARGET_GENERIC_ISSUE="aarch64 @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_vexpress_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca53"
+BR2_PLATFORM_CFG="vexpress_ca53_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca5_defconfig buildroot/configs/mbedtee_vexpress_ca5_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca5_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca5_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,48 @@
+BR2_arm=y
+BR2_cortex_a5=y
+BR2_ARM_ENABLE_NEON=y
+BR2_ARM_ENABLE_VFP=y
+BR2_ARM_FPU_VFPV3D16=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_ARMV7_EABIHF_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-arm"
+BR2_TARGET_GENERIC_ISSUE="arm @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv7a_vexpress_ca5_linux_config"
+BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y
+BR2_LINUX_KERNEL_IMAGE_TARGET_NAME="Image"
+BR2_LINUX_KERNEL_IMAGE_NAME="Image"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca5"
+BR2_PLATFORM_CFG="vexpress_ca5_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca65_defconfig buildroot/configs/mbedtee_vexpress_ca65_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca65_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca65_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a75=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-aarch64-multithread"
+BR2_TARGET_GENERIC_ISSUE="aarch64-multithread @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_vexpress_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca65"
+BR2_PLATFORM_CFG="vexpress_ca65_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca73x4_ca53x4_defconfig buildroot/configs/mbedtee_vexpress_ca73x4_ca53x4_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca73x4_ca53x4_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca73x4_ca53x4_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a73_a53=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-aarch64-big.LITTLE"
+BR2_TARGET_GENERIC_ISSUE="aarch64 big.LITTLE @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_vexpress_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca73x4_ca53x4"
+BR2_PLATFORM_CFG="vexpress_ca73x4_ca53x4_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/configs/mbedtee_vexpress_ca78_defconfig buildroot/configs/mbedtee_vexpress_ca78_defconfig
--- buildroot-ori/configs/mbedtee_vexpress_ca78_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/configs/mbedtee_vexpress_ca78_defconfig	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,42 @@
+BR2_aarch64=y
+BR2_cortex_a78=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN=y
+BR2_TOOLCHAIN_EXTERNAL_BOOTLIN_AARCH64_GLIBC_STABLE=y
+BR2_WGET="wget --passive-ftp -nd -t 3 --no-check-certificate"
+BR2_BACKUP_SITE="http://sources.buildroot.net"
+BR2_GNU_MIRROR="http://ftpmirror.gnu.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_OPTIMIZE_1=y
+BR2_SSP_NONE=y
+BR2_RELRO_NONE=y
+BR2_FORTIFY_SOURCE_NONE=y
+BR2_TARGET_GENERIC_HOSTNAME="fvp-aarch64"
+BR2_TARGET_GENERIC_ISSUE="aarch64 @ ARM FVP"
+BR2_ROOTFS_MERGED_USR=y
+# BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW is not set
+BR2_SYSTEM_DEFAULT_PATH="/bin:/sbin:/usr/bin:/usr/sbin"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="6.16.6"
+BR2_LINUX_KERNEL_PATCH="tee/linux/linux-patches"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="tee/linux/linux-configs/armv8a_vexpress_linux_config"
+BR2_PACKAGE_MBEDTEE=y
+BR2_PACKAGE_MBEDTEE_OS=y
+BR2_PACKAGE_MBEDTEE_CLIENT_APP=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT=y
+BR2_PACKAGE_MBEDTEE_TA=y
+BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA=y
+BR2_PLATFORM_NAME="vexpress_ca78"
+BR2_PLATFORM_CFG="vexpress_ca78_defconfig"
+BR2_PACKAGE_MBEDTEE_LINUX_DTS=y
+# BR2_PACKAGE_IFUPDOWN_SCRIPTS is not set
+# BR2_PACKAGE_URANDOM_SCRIPTS is not set
+BR2_TARGET_ROOTFS_CPIO_GZIP=y
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_PACKAGE_HOST_DOSFSTOOLS=y
+BR2_PACKAGE_HOST_DTC=y
+BR2_PACKAGE_HOST_MKPASSWD=y
+BR2_PACKAGE_HOST_MTOOLS=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/linux/linux.mk buildroot/linux/linux.mk
--- buildroot-ori/linux/linux.mk	2025-10-08 11:12:36.757903539 +0800
+++ buildroot/linux/linux.mk	2025-10-07 17:40:23.633155074 +0800
@@ -123,6 +123,10 @@ ifeq ($(BR2_LINUX_KERNEL_NEEDS_HOST_OPEN
 LINUX_DEPENDENCIES += host-openssl
 endif
 
+ifeq ($(BR2_PACKAGE_MBEDTEE),y)
+LINUX_DEPENDENCIES += mbedtee-common mbedtee-linux-dts
+endif
+
 ifeq ($(BR2_LINUX_KERNEL_NEEDS_HOST_LIBELF),y)
 LINUX_DEPENDENCIES += host-elfutils host-pkgconf
 endif
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/Makefile buildroot/Makefile
--- buildroot-ori/Makefile	2025-10-08 11:12:36.480705729 +0800
+++ buildroot/Makefile	2025-10-07 12:05:15.453398928 +0800
@@ -536,6 +536,7 @@ include $(sort $(wildcard package/*/*.mk
 
 include boot/common.mk
 include linux/linux.mk
+include tee/common.mk
 include fs/common.mk
 
 # If using a br2-external tree, the BR2_EXTERNAL_$(NAME)_PATH variables
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/package/busybox/inittab buildroot/package/busybox/inittab
--- buildroot-ori/package/busybox/inittab	2025-10-08 11:12:36.832957097 +0800
+++ buildroot/package/busybox/inittab	2025-10-07 12:05:15.454400202 +0800
@@ -29,7 +29,7 @@ null::sysinit:/bin/ln -sf /proc/self/fd/
 ::sysinit:/etc/init.d/rcS
 
 # Put a getty on the serial port
-#ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100 # GENERIC_SERIAL
+console::respawn:-/bin/sh
 
 # Stuff to do for the 3-finger salute
 #::ctrlaltdel:/sbin/reboot
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/package/pkg-autotools.mk buildroot/package/pkg-autotools.mk
--- buildroot-ori/package/pkg-autotools.mk	2025-10-08 11:12:37.781623632 +0800
+++ buildroot/package/pkg-autotools.mk	2025-10-07 12:05:15.454400202 +0800
@@ -200,6 +200,7 @@ else
 # because it often relies on host tools which may or may not be
 # installed.
 define $(2)_CONFIGURE_CMDS
+	@cd $$($$(PKG)_SRCDIR) && find . -exec touch -c -t 202010010000 --time=mtime '{}' +
 	(cd $$($$(PKG)_SRCDIR) && rm -rf config.cache; \
 	$$(HOST_CONFIGURE_OPTS) \
 	$$($$(PKG)_CONF_ENV) \
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/package/pkg-generic.mk buildroot/package/pkg-generic.mk
--- buildroot-ori/package/pkg-generic.mk	2025-10-08 11:12:37.782624332 +0800
+++ buildroot/package/pkg-generic.mk	2025-10-07 12:05:15.455401476 +0800
@@ -215,6 +215,7 @@ $(BUILD_DIR)/%/.stamp_extracted:
 	$(Q)chmod -R +rw $(@D)
 	$(foreach hook,$($(PKG)_POST_EXTRACT_HOOKS),$(call $(hook))$(sep))
 	@$(call step_end,extract)
+	@find $(@D) -exec touch -c -t 202010010000 --time=mtime '{}' +
 	$(Q)touch $@
 
 # Rsync the source directory if the <pkg>_OVERRIDE_SRCDIR feature is
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/common.mk buildroot/tee/common.mk
--- buildroot-ori/tee/common.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/common.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1 @@
+include $(sort $(wildcard tee/*/*.mk))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/Config.in buildroot/tee/Config.in
--- buildroot-ori/tee/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,8 @@
+menu "TEE"
+
+source "tee/mbedtee/Config.in"
+
+source "tee/linux/Config.in"
+
+endmenu
+
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/common.mk buildroot/tee/linux/common.mk
--- buildroot-ori/tee/linux/common.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/common.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1 @@
+include $(sort $(wildcard tee/linux/*/*.mk))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/Config.in buildroot/tee/linux/Config.in
--- buildroot-ori/tee/linux/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1 @@
+source "tee/linux/mbedtee-linux-dts/Config.in"
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv7a_qemu_ast2600_linux_config buildroot/tee/linux/linux-configs/armv7a_qemu_ast2600_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv7a_qemu_ast2600_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv7a_qemu_ast2600_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,105 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_FULL=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_RSEQ is not set
+CONFIG_ARCH_VIRT=y
+# CONFIG_HARDEN_BRANCH_PREDICTOR is not set
+# CONFIG_KUSER_HELPERS is not set
+# CONFIG_VDSO is not set
+# CONFIG_CACHE_L2X0 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rootwait earlycon=uart8250,mmio32,0x1e784000,115200n8"
+CONFIG_CMDLINE_FORCE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_ARM_SMCCC_SOC_ID is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_PRINTK_TIME=y
+# CONFIG_SYMBOLIC_ERRNAME is not set
+# CONFIG_DEBUG_MISC is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+CONFIG_UNWINDER_FRAME_POINTER=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv7a_qemu_imx7d_linux_config buildroot/tee/linux/linux-configs/armv7a_qemu_imx7d_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv7a_qemu_imx7d_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv7a_qemu_imx7d_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,104 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_FULL=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+# CONFIG_RSEQ is not set
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ARCH_MXC=y
+CONFIG_SOC_IMX7D=y
+# CONFIG_HARDEN_BRANCH_PREDICTOR is not set
+# CONFIG_KUSER_HELPERS is not set
+# CONFIG_VDSO is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_ARM_ERRATA_798181=y
+CONFIG_ARM_ERRATA_773022=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_ARM_PSCI=y
+CONFIG_HZ_1000=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_RESET_CONTROLLER is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_CRYPTO_DRBG_MENU=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_PRINTK_TIME=y
+# CONFIG_SYMBOLIC_ERRNAME is not set
+# CONFIG_DEBUG_MISC is not set
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+CONFIG_UNWINDER_FRAME_POINTER=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv7a_qemu_virt_linux_config buildroot/tee/linux/linux-configs/armv7a_qemu_virt_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv7a_qemu_virt_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv7a_qemu_virt_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,103 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_FULL=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_RSEQ is not set
+CONFIG_ARCH_VIRT=y
+# CONFIG_HARDEN_BRANCH_PREDICTOR is not set
+# CONFIG_KUSER_HELPERS is not set
+# CONFIG_VDSO is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_ARM_ERRATA_798181=y
+CONFIG_ARM_ERRATA_773022=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0x09000000"
+CONFIG_CMDLINE_FORCE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_SYMBOLIC_ERRNAME is not set
+# CONFIG_DEBUG_MISC is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+CONFIG_UNWINDER_FRAME_POINTER=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv7a_vexpress_ca15_linux_config buildroot/tee/linux/linux-configs/armv7a_vexpress_ca15_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv7a_vexpress_ca15_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv7a_vexpress_ca15_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,105 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_FULL=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_RSEQ is not set
+CONFIG_ARCH_VEXPRESS=y
+# CONFIG_HARDEN_BRANCH_PREDICTOR is not set
+# CONFIG_KUSER_HELPERS is not set
+# CONFIG_VDSO is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_ERRATA_798181=y
+CONFIG_ARM_ERRATA_773022=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_ARM_PSCI=y
+CONFIG_HZ_1000=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0x1c090000"
+CONFIG_CMDLINE_FORCE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_CLK_SP810 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_SYMBOLIC_ERRNAME is not set
+# CONFIG_DEBUG_MISC is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+CONFIG_UNWINDER_FRAME_POINTER=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv7a_vexpress_ca5_linux_config buildroot/tee/linux/linux-configs/armv7a_vexpress_ca5_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv7a_vexpress_ca5_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv7a_vexpress_ca5_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,102 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_FULL=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_RSEQ is not set
+CONFIG_ARCH_VEXPRESS=y
+# CONFIG_HARDEN_BRANCH_PREDICTOR is not set
+# CONFIG_KUSER_HELPERS is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_ERRATA_773022=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_ARM_PSCI=y
+CONFIG_HZ_1000=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0x1c090000"
+CONFIG_CMDLINE_FORCE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_CLK_VEXPRESS_OSC is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_SYMBOLIC_ERRNAME is not set
+# CONFIG_DEBUG_MISC is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+CONFIG_UNWINDER_FRAME_POINTER=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv8a_qemu_ast2700_linux_config buildroot/tee/linux/linux-configs/armv8a_qemu_ast2700_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv8a_qemu_ast2700_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv8a_qemu_ast2700_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,100 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+# CONFIG_RSEQ is not set
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ARCH_ASPEED=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rootwait earlycon=uart8250,mmio32,0x14c33b00"
+CONFIG_CMDLINE_FORCE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_ZONE_DMA is not set
+# CONFIG_ZONE_DMA32 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_COMMON_CLK_ASPEED is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_ASPEED_LPC_CTRL is not set
+# CONFIG_ASPEED_LPC_SNOOP is not set
+# CONFIG_ASPEED_UART_ROUTING is not set
+# CONFIG_ASPEED_P2A_CTRL is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_DEBUG_FS=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv8a_qemu_raspi4b_linux_config buildroot/tee/linux/linux-configs/armv8a_qemu_raspi4b_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv8a_qemu_raspi4b_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv8a_qemu_raspi4b_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,95 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+# CONFIG_RSEQ is not set
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ARCH_BCM=y
+CONFIG_ARCH_BCM2835=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0xfe201000"
+CONFIG_CMDLINE_FORCE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_ZONE_DMA is not set
+# CONFIG_ZONE_DMA32 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+CONFIG_VEXPRESS_CONFIG=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_ARM64_PLATFORM_DEVICES is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_DEBUG_FS=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv8a_qemu_virt_linux_config buildroot/tee/linux/linux-configs/armv8a_qemu_virt_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv8a_qemu_virt_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv8a_qemu_virt_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,97 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_RSEQ is not set
+# CONFIG_ARM64_ERRATUM_2441007 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0x09000000"
+CONFIG_CMDLINE_FORCE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_ZONE_DMA is not set
+# CONFIG_ZONE_DMA32 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+CONFIG_VEXPRESS_CONFIG=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv8a_qemu_xlnx_versal_virt_linux_config buildroot/tee/linux/linux-configs/armv8a_qemu_xlnx_versal_virt_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv8a_qemu_xlnx_versal_virt_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv8a_qemu_xlnx_versal_virt_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,97 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+# CONFIG_RSEQ is not set
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ARCH_ZYNQMP=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0xff000000"
+CONFIG_CMDLINE_FORCE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_ZONE_DMA is not set
+# CONFIG_ZONE_DMA32 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+CONFIG_VEXPRESS_CONFIG=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_ARM64_PLATFORM_DEVICES is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_SIMPLE=y
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_DEBUG_FS=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv8a_qemu_xlnx_zcu102_linux_config buildroot/tee/linux/linux-configs/armv8a_qemu_xlnx_zcu102_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv8a_qemu_xlnx_zcu102_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv8a_qemu_xlnx_zcu102_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,93 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+# CONFIG_RSEQ is not set
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ARCH_ZYNQMP=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_CMDLINE=""
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_ZONE_DMA is not set
+# CONFIG_ZONE_DMA32 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_ZYNQMP_FIRMWARE is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_ARM64_PLATFORM_DEVICES is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_DEBUG_FS=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/armv8a_vexpress_linux_config buildroot/tee/linux/linux-configs/armv8a_vexpress_linux_config
--- buildroot-ori/tee/linux/linux-configs/armv8a_vexpress_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/armv8a_vexpress_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,97 @@
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+CONFIG_INITRAMFS_FORCE=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_FHANDLE is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+# CONFIG_IO_URING is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_RSEQ is not set
+# CONFIG_ARM64_ERRATUM_2441007 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=16
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_1000=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_CMDLINE="console=ttyAMA0,115200n8 root=/dev/ram0 rootwait earlycon=pl011,mmio32,0x1c090000"
+CONFIG_CMDLINE_FORCE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_SECCOMP is not set
+# CONFIG_STACKPROTECTOR is not set
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+# CONFIG_ZONE_DMA is not set
+# CONFIG_ZONE_DMA32 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+CONFIG_VEXPRESS_CONFIG=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LDISC_AUTOLOAD is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_VALIDATE_FS_PARSER=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+CONFIG_INIT_STACK_NONE=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/riscv32_qemu_virt_linux_config buildroot/tee/linux/linux-configs/riscv32_qemu_virt_linux_config
--- buildroot-ori/tee/linux/linux-configs/riscv32_qemu_virt_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/riscv32_qemu_virt_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,148 @@
+CONFIG_COMPILE_TEST=y
+# CONFIG_WERROR is not set
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_PROFILING=y
+CONFIG_SOC_SIFIVE=y
+CONFIG_SOC_VIRT=y
+CONFIG_NONPORTABLE=y
+CONFIG_ARCH_RV32I=y
+CONFIG_CMODEL_MEDANY=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=64
+CONFIG_HZ_1000=y
+CONFIG_CPU_IDLE=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_PAGE_REPORTING=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_HW_RANDOM_MESON=y
+CONFIG_HW_RANDOM_MTK=y
+CONFIG_HW_RANDOM_EXYNOS=y
+CONFIG_HW_RANDOM_NPCM=y
+CONFIG_I2C=y
+CONFIG_SPI=y
+CONFIG_SPI_SIFIVE=y
+CONFIG_PINCTRL=y
+CONFIG_GPIO_SIFIVE=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_MMC_SPI=y
+CONFIG_RTC_CLASS=y
+CONFIG_DMADEVICES=y
+CONFIG_SYNC_FILE=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+CONFIG_RPMSG_CTRL=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_DAX=y
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_AUTOFS_FS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SECURITY_PATH=y
+CONFIG_INIT_STACK_ALL_ZERO=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_BLAKE2B=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_XXHASH=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_LIBCRC32C=y
+CONFIG_XZ_DEC=y
+CONFIG_PRINTK_TIME=y
+CONFIG_FRAME_WARN=2048
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_DEBUG_VM=y
+CONFIG_DEBUG_VM_PGFLAGS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_PER_CPU_MAPS=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_WQ_WATCHDOG=y
+CONFIG_DEBUG_TIMEKEEPING=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_DEBUG_LIST=y
+CONFIG_DEBUG_PLIST=y
+CONFIG_DEBUG_SG=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_EQS_DEBUG=y
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
+CONFIG_MEMTEST=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-configs/riscv64_qemu_virt_linux_config buildroot/tee/linux/linux-configs/riscv64_qemu_virt_linux_config
--- buildroot-ori/tee/linux/linux-configs/riscv64_qemu_virt_linux_config	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-configs/riscv64_qemu_virt_linux_config	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,146 @@
+CONFIG_COMPILE_TEST=y
+# CONFIG_WERROR is not set
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${BR_BINARIES_DIR}/rootfs.cpio"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_EXPERT=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_PROFILING=y
+CONFIG_SOC_SIFIVE=y
+CONFIG_SOC_VIRT=y
+CONFIG_NONPORTABLE=y
+CONFIG_SMP=y
+CONFIG_HZ_1000=y
+# CONFIG_COMPAT is not set
+CONFIG_CPU_IDLE=y
+CONFIG_JUMP_LABEL=y
+CONFIG_COMPAT_32BIT_TIME=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_BLOCK is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_PAGE_REPORTING=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_HW_RANDOM_MESON=y
+CONFIG_HW_RANDOM_MTK=y
+CONFIG_HW_RANDOM_EXYNOS=y
+CONFIG_HW_RANDOM_NPCM=y
+CONFIG_I2C=y
+CONFIG_SPI=y
+CONFIG_SPI_SIFIVE=y
+CONFIG_PINCTRL=y
+CONFIG_GPIO_SIFIVE=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_MMC_SPI=y
+CONFIG_RTC_CLASS=y
+CONFIG_DMADEVICES=y
+CONFIG_SYNC_FILE=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+CONFIG_RPMSG_CTRL=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_DAX=y
+CONFIG_TEE=y
+CONFIG_MBEDTEE=y
+CONFIG_AUTOFS_FS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SECURITY_PATH=y
+CONFIG_INIT_STACK_ALL_ZERO=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_BLAKE2B=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_XXHASH=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_LIBCRC32C=y
+CONFIG_XZ_DEC=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_DEBUG_VM=y
+CONFIG_DEBUG_VM_PGFLAGS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_PER_CPU_MAPS=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_WQ_WATCHDOG=y
+CONFIG_DEBUG_TIMEKEEPING=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_DEBUG_LIST=y
+CONFIG_DEBUG_PLIST=y
+CONFIG_DEBUG_SG=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_EQS_DEBUG=y
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
+CONFIG_MEMTEST=y
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-5.15.175.patch-- buildroot/tee/linux/linux-patches/mbedtee-linux-5.15.175.patch--
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-5.15.175.patch--	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-5.15.175.patch--	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2189 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/arch/arm/boot/compressed/head.S linux-5.15.175/arch/arm/boot/compressed/head.S
+--- linux-5.15.175-ori/arch/arm/boot/compressed/head.S	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/arch/arm/boot/compressed/head.S	2024-12-30 16:28:15.780408697 +0800
+@@ -313,7 +313,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/arch/arm/kernel/head.S linux-5.15.175/arch/arm/kernel/head.S
+--- linux-5.15.175-ori/arch/arm/kernel/head.S	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/arch/arm/kernel/head.S	2024-12-30 16:28:15.781408697 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/arch/arm/kernel/smp.c linux-5.15.175/arch/arm/kernel/smp.c
+--- linux-5.15.175-ori/arch/arm/kernel/smp.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/arch/arm/kernel/smp.c	2024-12-30 16:28:15.781408697 +0800
+@@ -66,20 +66,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -667,6 +668,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/arch/arm/Makefile linux-5.15.175/arch/arm/Makefile
+--- linux-5.15.175-ori/arch/arm/Makefile	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/arch/arm/Makefile	2024-12-30 16:28:15.782408697 +0800
+@@ -138,7 +138,7 @@ head-y		:= arch/arm/kernel/head$(MMUEXT)
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # We don't want the htc bootloader to corrupt kernel during resume
+ textofs-$(CONFIG_PM_H1940)      := 0x00108000
+ # RTD1195 has Boot ROM at start of address space
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/arch/arm64/kernel/smp.c linux-5.15.175/arch/arm64/kernel/smp.c
+--- linux-5.15.175-ori/arch/arm64/kernel/smp.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/arch/arm64/kernel/smp.c	2024-12-30 16:28:15.783408697 +0800
+@@ -74,6 +74,8 @@ enum ipi_msg_type {
+ 	IPI_TIMER,
+ 	IPI_IRQ_WORK,
+ 	IPI_WAKEUP,
++	IPI_RESERVED, /* 0 ~ 7 for REE */
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	NR_IPI
+ };
+ 
+@@ -928,6 +930,12 @@ static void do_handle_IPI(int ipinr)
+ 		break;
+ #endif
+ 
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
++
+ #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
+ 	case IPI_WAKEUP:
+ 		WARN_ONCE(!acpi_parking_protocol_valid(cpu),
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/arch/riscv/kernel/smp.c linux-5.15.175/arch/riscv/kernel/smp.c
+--- linux-5.15.175-ori/arch/riscv/kernel/smp.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/arch/riscv/kernel/smp.c	2024-12-30 18:28:55.657441310 +0800
+@@ -133,11 +133,14 @@ void handle_IPI(struct pt_regs *regs)
+ 	struct pt_regs *old_regs = set_irq_regs(regs);
+ 	unsigned long *pending_ipis = &ipi_data[smp_processor_id()].bits;
+ 	unsigned long *stats = ipi_data[smp_processor_id()].stats;
++	extern void mbedtee_rpc_isr(void);
+ 
+ 	irq_enter();
+ 
+ 	riscv_clear_ipi();
+ 
++	mbedtee_rpc_isr();
++
+ 	while (true) {
+ 		unsigned long ops;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/firmware/psci/psci.c linux-5.15.175/drivers/firmware/psci/psci.c
+--- linux-5.15.175-ori/drivers/firmware/psci/psci.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/firmware/psci/psci.c	2024-12-30 16:28:15.784408697 +0800
+@@ -260,12 +260,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/irqchip/irq-gic.c linux-5.15.175/drivers/irqchip/irq-gic.c
+--- linux-5.15.175-ori/drivers/irqchip/irq-gic.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/irqchip/irq-gic.c	2024-12-30 16:28:15.786408697 +0800
+@@ -866,13 +866,17 @@ static __init void gic_smp_init(void)
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+ 
+-	base_sgi = __irq_domain_alloc_irqs(gic_data[0].domain, -1, 8,
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = __irq_domain_alloc_irqs(gic_data[0].domain, -1, 16,
+ 					   NUMA_NO_NODE, &sgi_fwspec,
+ 					   false, NULL);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/irqchip/irq-gic-v3.c linux-5.15.175/drivers/irqchip/irq-gic-v3.c
+--- linux-5.15.175-ori/drivers/irqchip/irq-gic-v3.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/irqchip/irq-gic-v3.c	2024-12-30 16:28:15.787408697 +0800
+@@ -1272,13 +1272,17 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = __irq_domain_alloc_irqs(gic_data.domain, -1, 8,
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = __irq_domain_alloc_irqs(gic_data.domain, -1, 16,
+ 					   NUMA_NO_NODE, &sgi_fwspec,
+ 					   false, NULL);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/Kconfig linux-5.15.175/drivers/tee/Kconfig
+--- linux-5.15.175-ori/drivers/tee/Kconfig	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/tee/Kconfig	2024-12-30 16:28:15.788408697 +0800
+@@ -17,6 +17,8 @@ menu "TEE drivers"
+ 
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
++source "drivers/tee/mbedtee/Kconfig"
++
+ endmenu
+ 
+ endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/Makefile linux-5.15.175/drivers/tee/Makefile
+--- linux-5.15.175-ori/drivers/tee/Makefile	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/tee/Makefile	2024-12-30 16:28:15.788408697 +0800
+@@ -5,3 +5,4 @@ tee-objs += tee_shm.o
+ tee-objs += tee_shm_pool.o
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/core.c linux-5.15.175/drivers/tee/mbedtee/core.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/core.c	2024-12-30 16:28:15.789408697 +0800
+@@ -0,0 +1,280 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++static struct tee_shm_pool *mbedtee_config_dyn_shm(void)
++{
++	struct tee_shm_pool_mgr *priv_mgr;
++	struct tee_shm_pool_mgr *dmabuf_mgr;
++	void *rc;
++
++	rc = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR(rc))
++		return rc;
++	priv_mgr = rc;
++
++	rc = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR(rc)) {
++		tee_shm_pool_mgr_destroy(priv_mgr);
++		return rc;
++	}
++	dmabuf_mgr = rc;
++
++	rc = tee_shm_pool_alloc(priv_mgr, dmabuf_mgr);
++	if (IS_ERR(rc)) {
++		tee_shm_pool_mgr_destroy(priv_mgr);
++		tee_shm_pool_mgr_destroy(dmabuf_mgr);
++	}
++
++	return rc;
++}
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool_mgr *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_config_dyn_shm();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_config_dyn_shm();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/Kconfig linux-5.15.175/drivers/tee/mbedtee/Kconfig
+--- linux-5.15.175-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/Kconfig	2024-12-30 16:28:15.789408697 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/Makefile linux-5.15.175/drivers/tee/mbedtee/Makefile
+--- linux-5.15.175-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/Makefile	2024-12-30 16:28:15.789408697 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-5.15.175/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-5.15.175-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/mbedtee_drv.h	2024-12-30 17:29:00.327445268 +0800
+@@ -0,0 +1,154 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/syscalls.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-5.15.175/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-5.15.175-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/mbedtee_rpc.h	2024-12-30 16:28:15.789408697 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/rpc.c linux-5.15.175/drivers/tee/mbedtee/rpc.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/rpc.c	2024-12-30 16:28:15.790408697 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/rpc-callee.c linux-5.15.175/drivers/tee/mbedtee/rpc-callee.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/rpc-callee.c	2024-12-30 18:28:35.151694655 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-5.15.175/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/rpc-caller-arm.c	2024-12-30 16:28:15.790408697 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-5.15.175/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/rpc-caller-riscv.c	2024-12-30 18:28:40.151345508 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/shm_pool.c linux-5.15.175/drivers/tee/mbedtee/shm_pool.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/shm_pool.c	2024-12-30 16:28:15.790408697 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool_mgr *pool,
++			 struct tee_shm *shm, size_t size)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool_mgr *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool_mgr *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_mgr_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_poolmgr = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool_mgr *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool_mgr *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/shm_pool.h linux-5.15.175/drivers/tee/mbedtee/shm_pool.h
+--- linux-5.15.175-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/shm_pool.h	2024-12-30 16:28:15.790408697 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool_mgr *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/mbedtee/supp.c linux-5.15.175/drivers/tee/mbedtee/supp.c
+--- linux-5.15.175-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-5.15.175/drivers/tee/mbedtee/supp.c	2024-12-30 16:28:15.791408697 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tee/tee_core.c linux-5.15.175/drivers/tee/tee_core.c
+--- linux-5.15.175-ori/drivers/tee/tee_core.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/tee/tee_core.c	2024-12-30 16:28:15.791408697 +0800
+@@ -581,8 +581,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/drivers/tty/serial/amba-pl011.c linux-5.15.175/drivers/tty/serial/amba-pl011.c
+--- linux-5.15.175-ori/drivers/tty/serial/amba-pl011.c	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/drivers/tty/serial/amba-pl011.c	2024-12-30 16:28:15.792408697 +0800
+@@ -2610,6 +2610,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2628,6 +2673,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/include/linux/tee_drv.h linux-5.15.175/include/linux/tee_drv.h
+--- linux-5.15.175-ori/include/linux/tee_drv.h	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/include/linux/tee_drv.h	2024-12-30 16:28:15.793408697 +0800
+@@ -213,6 +213,7 @@ struct tee_shm {
+ 	refcount_t refcount;
+ 	u32 flags;
+ 	int id;
++	u64 sec_world_id;
+ };
+ 
+ /**
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-5.15.175-ori/include/uapi/linux/tee.h linux-5.15.175/include/uapi/linux/tee.h
+--- linux-5.15.175-ori/include/uapi/linux/tee.h	2024-12-20 01:07:23.000000000 +0800
++++ linux-5.15.175/include/uapi/linux/tee.h	2024-12-30 16:28:15.793408697 +0800
+@@ -61,6 +61,8 @@
+ #define TEE_IMPL_ID_OPTEE	1
+ #define TEE_IMPL_ID_AMDTEE	2
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.1.122.patch-- buildroot/tee/linux/linux-patches/mbedtee-linux-6.1.122.patch--
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.1.122.patch--	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-6.1.122.patch--	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2147 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/arch/arm/boot/compressed/head.S linux-6.1.122/arch/arm/boot/compressed/head.S
+--- linux-6.1.122-ori/arch/arm/boot/compressed/head.S	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/arch/arm/boot/compressed/head.S	2024-12-30 11:15:09.002023080 +0800
+@@ -309,7 +309,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/arch/arm/kernel/head.S linux-6.1.122/arch/arm/kernel/head.S
+--- linux-6.1.122-ori/arch/arm/kernel/head.S	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/arch/arm/kernel/head.S	2024-12-30 11:15:09.002023080 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/arch/arm/kernel/smp.c linux-6.1.122/arch/arm/kernel/smp.c
+--- linux-6.1.122-ori/arch/arm/kernel/smp.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/arch/arm/kernel/smp.c	2024-12-30 11:15:09.003023081 +0800
+@@ -66,20 +66,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -679,6 +680,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/arch/arm/Makefile linux-6.1.122/arch/arm/Makefile
+--- linux-6.1.122-ori/arch/arm/Makefile	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/arch/arm/Makefile	2024-12-30 11:15:09.003023081 +0800
+@@ -142,7 +142,7 @@ CHECKFLAGS	+= -D__arm__
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # We don't want the htc bootloader to corrupt kernel during resume
+ textofs-$(CONFIG_PM_H1940)      := 0x00108000
+ # RTD1195 has Boot ROM at start of address space
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/arch/arm64/kernel/smp.c linux-6.1.122/arch/arm64/kernel/smp.c
+--- linux-6.1.122-ori/arch/arm64/kernel/smp.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/arch/arm64/kernel/smp.c	2024-12-30 11:15:09.004023081 +0800
+@@ -74,6 +74,8 @@ enum ipi_msg_type {
+ 	IPI_TIMER,
+ 	IPI_IRQ_WORK,
+ 	IPI_WAKEUP,
++	IPI_RESERVED, /* 0 ~ 7 for REE */
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	NR_IPI
+ };
+ 
+@@ -902,6 +904,12 @@ static void do_handle_IPI(int ipinr)
+ 		break;
+ #endif
+ 
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
++
+ #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
+ 	case IPI_WAKEUP:
+ 		WARN_ONCE(!acpi_parking_protocol_valid(cpu),
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/arch/riscv/kernel/smp.c linux-6.1.122/arch/riscv/kernel/smp.c
+--- linux-6.1.122-ori/arch/riscv/kernel/smp.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/arch/riscv/kernel/smp.c	2024-12-30 11:15:09.005023081 +0800
+@@ -155,9 +155,12 @@ void handle_IPI(struct pt_regs *regs)
+ 	unsigned int cpu = smp_processor_id();
+ 	unsigned long *pending_ipis = &ipi_data[cpu].bits;
+ 	unsigned long *stats = ipi_data[cpu].stats;
++	extern void mbedtee_rpc_isr(void);
+ 
+ 	riscv_clear_ipi();
+ 
++	mbedtee_rpc_isr();
++
+ 	while (true) {
+ 		unsigned long ops;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/firmware/psci/psci.c linux-6.1.122/drivers/firmware/psci/psci.c
+--- linux-6.1.122-ori/drivers/firmware/psci/psci.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/firmware/psci/psci.c	2024-12-30 11:15:09.005023081 +0800
+@@ -268,12 +268,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/irqchip/irq-gic.c linux-6.1.122/drivers/irqchip/irq-gic.c
+--- linux-6.1.122-ori/drivers/irqchip/irq-gic.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/irqchip/irq-gic.c	2024-12-30 11:15:09.005023081 +0800
+@@ -867,13 +867,17 @@ static __init void gic_smp_init(void)
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+ 
+-	base_sgi = __irq_domain_alloc_irqs(gic_data[0].domain, -1, 8,
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = __irq_domain_alloc_irqs(gic_data[0].domain, -1, 16,
+ 					   NUMA_NO_NODE, &sgi_fwspec,
+ 					   false, NULL);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/irqchip/irq-gic-v3.c linux-6.1.122/drivers/irqchip/irq-gic-v3.c
+--- linux-6.1.122-ori/drivers/irqchip/irq-gic-v3.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/irqchip/irq-gic-v3.c	2024-12-30 11:15:09.006023081 +0800
+@@ -1358,13 +1358,17 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = __irq_domain_alloc_irqs(gic_data.domain, -1, 8,
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = __irq_domain_alloc_irqs(gic_data.domain, -1, 16,
+ 					   NUMA_NO_NODE, &sgi_fwspec,
+ 					   false, NULL);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/Kconfig linux-6.1.122/drivers/tee/Kconfig
+--- linux-6.1.122-ori/drivers/tee/Kconfig	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/tee/Kconfig	2024-12-30 11:15:09.007023081 +0800
+@@ -15,5 +15,6 @@ if TEE
+ 
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
++source "drivers/tee/mbedtee/Kconfig"
+ 
+ endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/Makefile linux-6.1.122/drivers/tee/Makefile
+--- linux-6.1.122-ori/drivers/tee/Makefile	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/tee/Makefile	2024-12-30 11:15:09.007023081 +0800
+@@ -5,3 +5,4 @@ tee-objs += tee_shm.o
+ tee-objs += tee_shm_pool.o
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/core.c linux-6.1.122/drivers/tee/mbedtee/core.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/core.c	2024-12-30 11:15:09.007023081 +0800
+@@ -0,0 +1,253 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/Kconfig linux-6.1.122/drivers/tee/mbedtee/Kconfig
+--- linux-6.1.122-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/Kconfig	2024-12-30 11:15:09.007023081 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/Makefile linux-6.1.122/drivers/tee/mbedtee/Makefile
+--- linux-6.1.122-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/Makefile	2024-12-30 11:15:09.007023081 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-6.1.122/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-6.1.122-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/mbedtee_drv.h	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,154 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/syscalls.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-6.1.122/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-6.1.122-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/mbedtee_rpc.h	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/rpc.c linux-6.1.122/drivers/tee/mbedtee/rpc.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/rpc.c	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/rpc-callee.c linux-6.1.122/drivers/tee/mbedtee/rpc-callee.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/rpc-callee.c	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-6.1.122/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/rpc-caller-arm.c	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-6.1.122/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/rpc-caller-riscv.c	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/shm_pool.c linux-6.1.122/drivers/tee/mbedtee/shm_pool.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/shm_pool.c	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool *pool,
++			 struct tee_shm *shm, size_t size, size_t align)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_pool = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/shm_pool.h linux-6.1.122/drivers/tee/mbedtee/shm_pool.h
+--- linux-6.1.122-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/shm_pool.h	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/mbedtee/supp.c linux-6.1.122/drivers/tee/mbedtee/supp.c
+--- linux-6.1.122-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.1.122/drivers/tee/mbedtee/supp.c	2024-12-30 11:15:09.008023081 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tee/tee_core.c linux-6.1.122/drivers/tee/tee_core.c
+--- linux-6.1.122-ori/drivers/tee/tee_core.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/tee/tee_core.c	2024-12-30 11:15:09.009023081 +0800
+@@ -575,8 +575,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/drivers/tty/serial/amba-pl011.c linux-6.1.122/drivers/tty/serial/amba-pl011.c
+--- linux-6.1.122-ori/drivers/tty/serial/amba-pl011.c	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/drivers/tty/serial/amba-pl011.c	2024-12-30 11:15:09.009023081 +0800
+@@ -2590,6 +2590,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2608,6 +2653,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.1.122-ori/include/uapi/linux/tee.h linux-6.1.122/include/uapi/linux/tee.h
+--- linux-6.1.122-ori/include/uapi/linux/tee.h	2024-12-27 20:53:02.000000000 +0800
++++ linux-6.1.122/include/uapi/linux/tee.h	2024-12-30 11:15:09.010023081 +0800
+@@ -57,6 +57,8 @@
+ #define TEE_IMPL_ID_OPTEE	1
+ #define TEE_IMPL_ID_AMDTEE	2
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.12.7.patch-- buildroot/tee/linux/linux-patches/mbedtee-linux-6.12.7.patch--
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.12.7.patch--	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-6.12.7.patch--	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2151 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/arch/arm/boot/compressed/head.S linux-6.12.7/arch/arm/boot/compressed/head.S
+--- linux-6.12.7-ori/arch/arm/boot/compressed/head.S	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/arch/arm/boot/compressed/head.S	2024-12-30 14:49:15.298349268 +0800
+@@ -309,7 +309,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/arch/arm/kernel/head.S linux-6.12.7/arch/arm/kernel/head.S
+--- linux-6.12.7-ori/arch/arm/kernel/head.S	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/arch/arm/kernel/head.S	2024-12-30 14:49:15.299349268 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/arch/arm/kernel/smp.c linux-6.12.7/arch/arm/kernel/smp.c
+--- linux-6.12.7-ori/arch/arm/kernel/smp.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/arch/arm/kernel/smp.c	2024-12-30 14:49:15.299349268 +0800
+@@ -65,20 +65,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -675,6 +676,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/arch/arm/Makefile linux-6.12.7/arch/arm/Makefile
+--- linux-6.12.7-ori/arch/arm/Makefile	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/arch/arm/Makefile	2024-12-30 14:49:15.301349268 +0800
+@@ -158,7 +158,7 @@ CHECKFLAGS	+= -D__arm__
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # RTD1195 has Boot ROM at start of address space
+ textofs-$(CONFIG_ARCH_REALTEK)  := 0x00108000
+ # SA1111 DMA bug: we don't want the kernel to live in precious DMA-able memory
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/arch/arm64/kernel/smp.c linux-6.12.7/arch/arm64/kernel/smp.c
+--- linux-6.12.7-ori/arch/arm64/kernel/smp.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/arch/arm64/kernel/smp.c	2024-12-30 14:49:15.302349268 +0800
+@@ -71,6 +71,9 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP_NMI,
+ 	IPI_TIMER,
+ 	IPI_IRQ_WORK,
++	IPI_RESERVED1, /* 0 ~ 7 for REE */
++	IPI_RESERVED2, /* 0 ~ 7 for REE */
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	NR_IPI,
+ 	/*
+ 	 * Any enum >= NR_IPI and < MAX_IPI is special and not tracable
+@@ -990,6 +993,12 @@ static void do_handle_IPI(int ipinr)
+ 		break;
+ #endif
+ 
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
++
+ 	case IPI_CPU_BACKTRACE:
+ 		/*
+ 		 * NOTE: in some cases this _won't_ be NMI context. See the
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/arch/riscv/kernel/sbi-ipi.c linux-6.12.7/arch/riscv/kernel/sbi-ipi.c
+--- linux-6.12.7-ori/arch/riscv/kernel/sbi-ipi.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/arch/riscv/kernel/sbi-ipi.c	2024-12-30 14:49:15.303349268 +0800
+@@ -18,6 +18,8 @@ EXPORT_SYMBOL_GPL(riscv_sbi_for_rfence);
+ 
+ static int sbi_ipi_virq;
+ 
++extern void mbedtee_rpc_isr(void);
++
+ static void sbi_ipi_handle(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+@@ -27,6 +29,8 @@ static void sbi_ipi_handle(struct irq_de
+ 	csr_clear(CSR_IP, IE_SIE);
+ 	ipi_mux_process();
+ 
++	mbedtee_rpc_isr();
++
+ 	chained_irq_exit(chip, desc);
+ }
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/firmware/psci/psci.c linux-6.12.7/drivers/firmware/psci/psci.c
+--- linux-6.12.7-ori/drivers/firmware/psci/psci.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/firmware/psci/psci.c	2024-12-30 14:49:15.305349268 +0800
+@@ -269,12 +269,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/irqchip/irq-gic.c linux-6.12.7/drivers/irqchip/irq-gic.c
+--- linux-6.12.7-ori/drivers/irqchip/irq-gic.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/irqchip/irq-gic.c	2024-12-30 14:49:15.306349268 +0800
+@@ -864,12 +864,15 @@ static __init void gic_smp_init(void)
+ 	cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+-
+-	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/irqchip/irq-gic-v3.c linux-6.12.7/drivers/irqchip/irq-gic-v3.c
+--- linux-6.12.7-ori/drivers/irqchip/irq-gic-v3.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/irqchip/irq-gic-v3.c	2024-12-30 14:49:15.306349268 +0800
+@@ -1458,11 +1458,15 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/Kconfig linux-6.12.7/drivers/tee/Kconfig
+--- linux-6.12.7-ori/drivers/tee/Kconfig	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/tee/Kconfig	2024-12-30 14:49:15.307349268 +0800
+@@ -16,5 +16,6 @@ if TEE
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
+ source "drivers/tee/tstee/Kconfig"
++source "drivers/tee/mbedtee/Kconfig"
+ 
+ endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/Makefile linux-6.12.7/drivers/tee/Makefile
+--- linux-6.12.7-ori/drivers/tee/Makefile	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/tee/Makefile	2024-12-30 14:49:15.307349268 +0800
+@@ -6,3 +6,4 @@ tee-objs += tee_shm_pool.o
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
+ obj-$(CONFIG_ARM_TSTEE) += tstee/
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/core.c linux-6.12.7/drivers/tee/mbedtee/core.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/core.c	2024-12-30 14:49:15.308349268 +0800
+@@ -0,0 +1,253 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/Kconfig linux-6.12.7/drivers/tee/mbedtee/Kconfig
+--- linux-6.12.7-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/Kconfig	2024-12-30 14:49:15.308349268 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/Makefile linux-6.12.7/drivers/tee/mbedtee/Makefile
+--- linux-6.12.7-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/Makefile	2024-12-30 14:49:15.308349268 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-6.12.7/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-6.12.7-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/mbedtee_drv.h	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,155 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/tee_core.h>
++#include <linux/syscalls.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-6.12.7/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-6.12.7-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/mbedtee_rpc.h	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/rpc.c linux-6.12.7/drivers/tee/mbedtee/rpc.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/rpc.c	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/rpc-callee.c linux-6.12.7/drivers/tee/mbedtee/rpc-callee.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/rpc-callee.c	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-6.12.7/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/rpc-caller-arm.c	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-6.12.7/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/rpc-caller-riscv.c	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/shm_pool.c linux-6.12.7/drivers/tee/mbedtee/shm_pool.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/shm_pool.c	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool *pool,
++			 struct tee_shm *shm, size_t size, size_t align)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_pool = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/shm_pool.h linux-6.12.7/drivers/tee/mbedtee/shm_pool.h
+--- linux-6.12.7-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/shm_pool.h	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/mbedtee/supp.c linux-6.12.7/drivers/tee/mbedtee/supp.c
+--- linux-6.12.7-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.12.7/drivers/tee/mbedtee/supp.c	2024-12-30 14:49:15.309349269 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tee/tee_core.c linux-6.12.7/drivers/tee/tee_core.c
+--- linux-6.12.7-ori/drivers/tee/tee_core.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/tee/tee_core.c	2024-12-30 14:49:15.309349269 +0800
+@@ -575,8 +575,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/drivers/tty/serial/amba-pl011.c linux-6.12.7/drivers/tty/serial/amba-pl011.c
+--- linux-6.12.7-ori/drivers/tty/serial/amba-pl011.c	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/drivers/tty/serial/amba-pl011.c	2024-12-30 14:49:15.310349269 +0800
+@@ -2574,6 +2574,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2592,6 +2637,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.12.7-ori/include/uapi/linux/tee.h linux-6.12.7/include/uapi/linux/tee.h
+--- linux-6.12.7-ori/include/uapi/linux/tee.h	2024-12-27 21:02:20.000000000 +0800
++++ linux-6.12.7/include/uapi/linux/tee.h	2024-12-30 14:50:07.902309416 +0800
+@@ -58,6 +58,8 @@
+ #define TEE_IMPL_ID_AMDTEE	2
+ #define TEE_IMPL_ID_TSTEE	3
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.13-rc5.patch-- buildroot/tee/linux/linux-patches/mbedtee-linux-6.13-rc5.patch--
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.13-rc5.patch--	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-6.13-rc5.patch--	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2151 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/arch/arm/boot/compressed/head.S linux-6.13-rc5/arch/arm/boot/compressed/head.S
+--- linux-6.13-rc5-ori/arch/arm/boot/compressed/head.S	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/arch/arm/boot/compressed/head.S	2024-12-30 17:40:23.856610003 +0800
+@@ -309,7 +309,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/arch/arm/kernel/head.S linux-6.13-rc5/arch/arm/kernel/head.S
+--- linux-6.13-rc5-ori/arch/arm/kernel/head.S	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/arch/arm/kernel/head.S	2024-12-30 17:40:23.879610004 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/arch/arm/kernel/smp.c linux-6.13-rc5/arch/arm/kernel/smp.c
+--- linux-6.13-rc5-ori/arch/arm/kernel/smp.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/arch/arm/kernel/smp.c	2024-12-30 17:40:23.888610004 +0800
+@@ -65,20 +65,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -675,6 +676,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/arch/arm/Makefile linux-6.13-rc5/arch/arm/Makefile
+--- linux-6.13-rc5-ori/arch/arm/Makefile	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/arch/arm/Makefile	2024-12-30 17:40:23.889610004 +0800
+@@ -158,7 +158,7 @@ CHECKFLAGS	+= -D__arm__
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # RTD1195 has Boot ROM at start of address space
+ textofs-$(CONFIG_ARCH_REALTEK)  := 0x00108000
+ # SA1111 DMA bug: we don't want the kernel to live in precious DMA-able memory
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/arch/arm64/kernel/smp.c linux-6.13-rc5/arch/arm64/kernel/smp.c
+--- linux-6.13-rc5-ori/arch/arm64/kernel/smp.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/arch/arm64/kernel/smp.c	2024-12-30 17:40:23.890610004 +0800
+@@ -71,6 +71,9 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP_NMI,
+ 	IPI_TIMER,
+ 	IPI_IRQ_WORK,
++	IPI_RESERVED1, /* 0 ~ 7 for REE */
++	IPI_RESERVED2, /* 0 ~ 7 for REE */
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	NR_IPI,
+ 	/*
+ 	 * Any enum >= NR_IPI and < MAX_IPI is special and not tracable
+@@ -990,6 +993,12 @@ static void do_handle_IPI(int ipinr)
+ 		break;
+ #endif
+ 
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
++
+ 	case IPI_CPU_BACKTRACE:
+ 		/*
+ 		 * NOTE: in some cases this _won't_ be NMI context. See the
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/arch/riscv/kernel/sbi-ipi.c linux-6.13-rc5/arch/riscv/kernel/sbi-ipi.c
+--- linux-6.13-rc5-ori/arch/riscv/kernel/sbi-ipi.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/arch/riscv/kernel/sbi-ipi.c	2024-12-30 17:40:23.890610004 +0800
+@@ -18,6 +18,8 @@ EXPORT_SYMBOL_GPL(riscv_sbi_for_rfence);
+ 
+ static int sbi_ipi_virq;
+ 
++extern void mbedtee_rpc_isr(void);
++
+ static void sbi_ipi_handle(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+@@ -27,6 +29,8 @@ static void sbi_ipi_handle(struct irq_de
+ 	csr_clear(CSR_IP, IE_SIE);
+ 	ipi_mux_process();
+ 
++	mbedtee_rpc_isr();
++
+ 	chained_irq_exit(chip, desc);
+ }
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/firmware/psci/psci.c linux-6.13-rc5/drivers/firmware/psci/psci.c
+--- linux-6.13-rc5-ori/drivers/firmware/psci/psci.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/firmware/psci/psci.c	2024-12-30 17:40:23.891610004 +0800
+@@ -270,12 +270,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/irqchip/irq-gic.c linux-6.13-rc5/drivers/irqchip/irq-gic.c
+--- linux-6.13-rc5-ori/drivers/irqchip/irq-gic.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/irqchip/irq-gic.c	2024-12-30 17:40:23.891610004 +0800
+@@ -864,12 +864,15 @@ static __init void gic_smp_init(void)
+ 	cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+-
+-	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/irqchip/irq-gic-v3.c linux-6.13-rc5/drivers/irqchip/irq-gic-v3.c
+--- linux-6.13-rc5-ori/drivers/irqchip/irq-gic-v3.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/irqchip/irq-gic-v3.c	2024-12-30 17:40:23.892610004 +0800
+@@ -1458,11 +1458,15 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/Kconfig linux-6.13-rc5/drivers/tee/Kconfig
+--- linux-6.13-rc5-ori/drivers/tee/Kconfig	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/Kconfig	2024-12-30 17:40:23.892610004 +0800
+@@ -16,5 +16,6 @@ if TEE
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
+ source "drivers/tee/tstee/Kconfig"
++source "drivers/tee/mbedtee/Kconfig"
+ 
+ endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/Makefile linux-6.13-rc5/drivers/tee/Makefile
+--- linux-6.13-rc5-ori/drivers/tee/Makefile	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/Makefile	2024-12-30 17:40:23.907610004 +0800
+@@ -6,3 +6,4 @@ tee-objs += tee_shm_pool.o
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
+ obj-$(CONFIG_ARM_TSTEE) += tstee/
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/core.c linux-6.13-rc5/drivers/tee/mbedtee/core.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/core.c	2024-12-30 17:40:23.907610004 +0800
+@@ -0,0 +1,253 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/Kconfig linux-6.13-rc5/drivers/tee/mbedtee/Kconfig
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/Kconfig	2024-12-30 17:40:23.907610004 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/Makefile linux-6.13-rc5/drivers/tee/mbedtee/Makefile
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/Makefile	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-6.13-rc5/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/mbedtee_drv.h	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,155 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/tee_core.h>
++#include <linux/syscalls.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-6.13-rc5/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/mbedtee_rpc.h	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc.c linux-6.13-rc5/drivers/tee/mbedtee/rpc.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/rpc.c	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc-callee.c linux-6.13-rc5/drivers/tee/mbedtee/rpc-callee.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/rpc-callee.c	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-6.13-rc5/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/rpc-caller-arm.c	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-6.13-rc5/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/rpc-caller-riscv.c	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/shm_pool.c linux-6.13-rc5/drivers/tee/mbedtee/shm_pool.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/shm_pool.c	2024-12-30 17:40:23.908610004 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool *pool,
++			 struct tee_shm *shm, size_t size, size_t align)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_pool = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/shm_pool.h linux-6.13-rc5/drivers/tee/mbedtee/shm_pool.h
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/shm_pool.h	2024-12-30 17:40:23.909610004 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/mbedtee/supp.c linux-6.13-rc5/drivers/tee/mbedtee/supp.c
+--- linux-6.13-rc5-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/mbedtee/supp.c	2024-12-30 17:40:23.909610004 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tee/tee_core.c linux-6.13-rc5/drivers/tee/tee_core.c
+--- linux-6.13-rc5-ori/drivers/tee/tee_core.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/tee/tee_core.c	2024-12-30 17:40:23.909610004 +0800
+@@ -575,8 +575,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/drivers/tty/serial/amba-pl011.c linux-6.13-rc5/drivers/tty/serial/amba-pl011.c
+--- linux-6.13-rc5-ori/drivers/tty/serial/amba-pl011.c	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/drivers/tty/serial/amba-pl011.c	2024-12-30 17:40:23.909610004 +0800
+@@ -2574,6 +2574,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2592,6 +2637,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.13-rc5-ori/include/uapi/linux/tee.h linux-6.13-rc5/include/uapi/linux/tee.h
+--- linux-6.13-rc5-ori/include/uapi/linux/tee.h	2024-12-30 05:15:45.000000000 +0800
++++ linux-6.13-rc5/include/uapi/linux/tee.h	2024-12-30 17:40:23.910610005 +0800
+@@ -58,6 +58,8 @@
+ #define TEE_IMPL_ID_AMDTEE	2
+ #define TEE_IMPL_ID_TSTEE	3
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.16.6.patch buildroot/tee/linux/linux-patches/mbedtee-linux-6.16.6.patch
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.16.6.patch	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-6.16.6.patch	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2168 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/arm/boot/compressed/head.S linux-6.16.6/arch/arm/boot/compressed/head.S
+--- linux-6.16.6-ori/arch/arm/boot/compressed/head.S	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/arm/boot/compressed/head.S	2025-09-14 12:09:50.182683889 +0800
+@@ -309,7 +309,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/arm/kernel/head.S linux-6.16.6/arch/arm/kernel/head.S
+--- linux-6.16.6-ori/arch/arm/kernel/head.S	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/arm/kernel/head.S	2025-09-14 12:09:50.183683889 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/arm/kernel/smp.c linux-6.16.6/arch/arm/kernel/smp.c
+--- linux-6.16.6-ori/arch/arm/kernel/smp.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/arm/kernel/smp.c	2025-09-14 12:09:50.186683889 +0800
+@@ -65,20 +65,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -676,6 +677,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/arm/Makefile linux-6.16.6/arch/arm/Makefile
+--- linux-6.16.6-ori/arch/arm/Makefile	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/arm/Makefile	2025-09-14 12:09:50.189683889 +0800
+@@ -159,7 +159,7 @@ CHECKFLAGS	+= -D__arm__
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # RTD1195 has Boot ROM at start of address space
+ textofs-$(CONFIG_ARCH_REALTEK)  := 0x00108000
+ # SA1111 DMA bug: we don't want the kernel to live in precious DMA-able memory
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/arm64/Kconfig.platforms linux-6.16.6/arch/arm64/Kconfig.platforms
+--- linux-6.16.6-ori/arch/arm64/Kconfig.platforms	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/arm64/Kconfig.platforms	2025-09-14 12:11:59.263584472 +0800
+@@ -1,6 +1,11 @@
+ # SPDX-License-Identifier: GPL-2.0-only
+ menu "Platform selection"
+ 
++config ARCH_ASPEED
++	bool "Aspeed AST2700"
++	help
++	  This enables support for the Aspeed AST2700 temporarily.
++
+ config ARCH_ACTIONS
+ 	bool "Actions Semi Platforms"
+ 	select OWL_TIMER
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/arm64/kernel/smp.c linux-6.16.6/arch/arm64/kernel/smp.c
+--- linux-6.16.6-ori/arch/arm64/kernel/smp.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/arm64/kernel/smp.c	2025-09-14 12:09:50.189683889 +0800
+@@ -78,6 +78,7 @@ enum ipi_msg_type {
+ 	 */
+ 	IPI_CPU_BACKTRACE = NR_IPI,
+ 	IPI_KGDB_ROUNDUP,
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	MAX_IPI
+ };
+ 
+@@ -1002,6 +1003,12 @@ static void do_handle_IPI(int ipinr)
+ 		kgdb_nmicallback(cpu, get_irq_regs());
+ 		break;
+ 
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n", cpu, ipinr);
+ 		break;
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/arch/riscv/kernel/sbi-ipi.c linux-6.16.6/arch/riscv/kernel/sbi-ipi.c
+--- linux-6.16.6-ori/arch/riscv/kernel/sbi-ipi.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/arch/riscv/kernel/sbi-ipi.c	2025-09-14 12:09:50.193683888 +0800
+@@ -18,6 +18,8 @@ EXPORT_SYMBOL_GPL(riscv_sbi_for_rfence);
+ 
+ static int sbi_ipi_virq;
+ 
++extern void mbedtee_rpc_isr(void);
++
+ static void sbi_ipi_handle(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+@@ -27,6 +29,8 @@ static void sbi_ipi_handle(struct irq_de
+ 	csr_clear(CSR_IP, IE_SIE);
+ 	ipi_mux_process();
+ 
++	mbedtee_rpc_isr();
++
+ 	chained_irq_exit(chip, desc);
+ }
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/firmware/psci/psci.c linux-6.16.6/drivers/firmware/psci/psci.c
+--- linux-6.16.6-ori/drivers/firmware/psci/psci.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/firmware/psci/psci.c	2025-09-14 12:09:50.194683888 +0800
+@@ -270,12 +270,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/irqchip/irq-gic.c linux-6.16.6/drivers/irqchip/irq-gic.c
+--- linux-6.16.6-ori/drivers/irqchip/irq-gic.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/irqchip/irq-gic.c	2025-09-14 12:09:50.196683888 +0800
+@@ -864,12 +864,15 @@ static __init void gic_smp_init(void)
+ 	cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+-
+-	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/irqchip/irq-gic-v3.c linux-6.16.6/drivers/irqchip/irq-gic-v3.c
+--- linux-6.16.6-ori/drivers/irqchip/irq-gic-v3.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/irqchip/irq-gic-v3.c	2025-09-14 12:09:50.198683888 +0800
+@@ -1467,11 +1467,15 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/Kconfig linux-6.16.6/drivers/tee/Kconfig
+--- linux-6.16.6-ori/drivers/tee/Kconfig	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/tee/Kconfig	2025-09-14 12:09:50.198683888 +0800
+@@ -13,6 +13,7 @@ menuconfig TEE
+ 
+ if TEE
+ 
++source "drivers/tee/mbedtee/Kconfig"
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
+ source "drivers/tee/tstee/Kconfig"
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/Makefile linux-6.16.6/drivers/tee/Makefile
+--- linux-6.16.6-ori/drivers/tee/Makefile	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/tee/Makefile	2025-09-14 12:09:50.202683888 +0800
+@@ -3,6 +3,7 @@ obj-$(CONFIG_TEE) += tee.o
+ tee-objs += tee_core.o
+ tee-objs += tee_shm.o
+ tee-objs += tee_shm_pool.o
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
+ obj-$(CONFIG_ARM_TSTEE) += tstee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/core.c linux-6.16.6/drivers/tee/mbedtee/core.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/core.c	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,253 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/Kconfig linux-6.16.6/drivers/tee/mbedtee/Kconfig
+--- linux-6.16.6-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/Kconfig	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/Makefile linux-6.16.6/drivers/tee/mbedtee/Makefile
+--- linux-6.16.6-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/Makefile	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-6.16.6/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-6.16.6-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/mbedtee_drv.h	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,155 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/syscalls.h>
++#include <linux/tee_core.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-6.16.6/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-6.16.6-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/mbedtee_rpc.h	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/rpc.c linux-6.16.6/drivers/tee/mbedtee/rpc.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/rpc.c	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/rpc-callee.c linux-6.16.6/drivers/tee/mbedtee/rpc-callee.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/rpc-callee.c	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-6.16.6/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/rpc-caller-arm.c	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-6.16.6/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/rpc-caller-riscv.c	2025-09-14 12:09:50.203683888 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/shm_pool.c linux-6.16.6/drivers/tee/mbedtee/shm_pool.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/shm_pool.c	2025-09-14 12:09:50.205683887 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool *pool,
++			 struct tee_shm *shm, size_t size, size_t align)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_pool = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/shm_pool.h linux-6.16.6/drivers/tee/mbedtee/shm_pool.h
+--- linux-6.16.6-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/shm_pool.h	2025-09-14 12:09:50.205683887 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/mbedtee/supp.c linux-6.16.6/drivers/tee/mbedtee/supp.c
+--- linux-6.16.6-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.16.6/drivers/tee/mbedtee/supp.c	2025-09-14 12:09:50.205683887 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tee/tee_core.c linux-6.16.6/drivers/tee/tee_core.c
+--- linux-6.16.6-ori/drivers/tee/tee_core.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/tee/tee_core.c	2025-09-14 12:09:50.205683887 +0800
+@@ -576,8 +576,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/drivers/tty/serial/amba-pl011.c linux-6.16.6/drivers/tty/serial/amba-pl011.c
+--- linux-6.16.6-ori/drivers/tty/serial/amba-pl011.c	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/drivers/tty/serial/amba-pl011.c	2025-09-14 12:09:50.205683887 +0800
+@@ -2686,6 +2686,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2704,6 +2749,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.16.6-ori/include/uapi/linux/tee.h linux-6.16.6/include/uapi/linux/tee.h
+--- linux-6.16.6-ori/include/uapi/linux/tee.h	2025-09-10 01:02:41.000000000 +0800
++++ linux-6.16.6/include/uapi/linux/tee.h	2025-09-14 12:09:50.205683887 +0800
+@@ -58,6 +58,8 @@
+ #define TEE_IMPL_ID_AMDTEE	2
+ #define TEE_IMPL_ID_TSTEE	3
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.6.68.patch-- buildroot/tee/linux/linux-patches/mbedtee-linux-6.6.68.patch--
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.6.68.patch--	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-6.6.68.patch--	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2149 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/arch/arm/boot/compressed/head.S linux-6.6.68/arch/arm/boot/compressed/head.S
+--- linux-6.6.68-ori/arch/arm/boot/compressed/head.S	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/arch/arm/boot/compressed/head.S	2024-12-30 16:45:09.513525847 +0800
+@@ -309,7 +309,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/arch/arm/kernel/head.S linux-6.6.68/arch/arm/kernel/head.S
+--- linux-6.6.68-ori/arch/arm/kernel/head.S	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/arch/arm/kernel/head.S	2024-12-30 16:45:09.513525847 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/arch/arm/kernel/smp.c linux-6.6.68/arch/arm/kernel/smp.c
+--- linux-6.6.68-ori/arch/arm/kernel/smp.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/arch/arm/kernel/smp.c	2024-12-30 16:45:09.513525847 +0800
+@@ -65,20 +65,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -675,6 +676,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/arch/arm/Makefile linux-6.6.68/arch/arm/Makefile
+--- linux-6.6.68-ori/arch/arm/Makefile	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/arch/arm/Makefile	2024-12-30 16:45:09.514525847 +0800
+@@ -151,7 +151,7 @@ CHECKFLAGS	+= -D__arm__
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # RTD1195 has Boot ROM at start of address space
+ textofs-$(CONFIG_ARCH_REALTEK)  := 0x00108000
+ # SA1111 DMA bug: we don't want the kernel to live in precious DMA-able memory
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/arch/arm64/kernel/smp.c linux-6.6.68/arch/arm64/kernel/smp.c
+--- linux-6.6.68-ori/arch/arm64/kernel/smp.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/arch/arm64/kernel/smp.c	2024-12-30 16:45:09.514525847 +0800
+@@ -73,6 +73,8 @@ enum ipi_msg_type {
+ 	IPI_TIMER,
+ 	IPI_IRQ_WORK,
+ 	IPI_WAKEUP,
++	IPI_RESERVED, /* 0 ~ 7 for REE */
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	NR_IPI
+ };
+ 
+@@ -899,6 +901,12 @@ static void do_handle_IPI(int ipinr)
+ 		break;
+ #endif
+ 
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
++
+ #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
+ 	case IPI_WAKEUP:
+ 		WARN_ONCE(!acpi_parking_protocol_valid(cpu),
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/arch/riscv/kernel/sbi-ipi.c linux-6.6.68/arch/riscv/kernel/sbi-ipi.c
+--- linux-6.6.68-ori/arch/riscv/kernel/sbi-ipi.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/arch/riscv/kernel/sbi-ipi.c	2024-12-30 16:45:09.514525847 +0800
+@@ -15,6 +15,8 @@
+ 
+ static int sbi_ipi_virq;
+ 
++extern void mbedtee_rpc_isr(void);
++
+ static void sbi_ipi_handle(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+@@ -24,6 +26,8 @@ static void sbi_ipi_handle(struct irq_de
+ 	csr_clear(CSR_IP, IE_SIE);
+ 	ipi_mux_process();
+ 
++	mbedtee_rpc_isr();
++
+ 	chained_irq_exit(chip, desc);
+ }
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/firmware/psci/psci.c linux-6.6.68/drivers/firmware/psci/psci.c
+--- linux-6.6.68-ori/drivers/firmware/psci/psci.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/firmware/psci/psci.c	2024-12-30 16:45:09.515525847 +0800
+@@ -269,12 +269,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/irqchip/irq-gic.c linux-6.6.68/drivers/irqchip/irq-gic.c
+--- linux-6.6.68-ori/drivers/irqchip/irq-gic.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/irqchip/irq-gic.c	2024-12-30 16:45:09.515525847 +0800
+@@ -867,12 +867,15 @@ static __init void gic_smp_init(void)
+ 	cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+-
+-	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/irqchip/irq-gic-v3.c linux-6.6.68/drivers/irqchip/irq-gic-v3.c
+--- linux-6.6.68-ori/drivers/irqchip/irq-gic-v3.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/irqchip/irq-gic-v3.c	2024-12-30 16:45:09.515525847 +0800
+@@ -1396,11 +1396,15 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/Kconfig linux-6.6.68/drivers/tee/Kconfig
+--- linux-6.6.68-ori/drivers/tee/Kconfig	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/tee/Kconfig	2024-12-30 16:45:09.516525847 +0800
+@@ -15,5 +15,6 @@ if TEE
+ 
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
++source "drivers/tee/mbedtee/Kconfig"
+ 
+ endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/Makefile linux-6.6.68/drivers/tee/Makefile
+--- linux-6.6.68-ori/drivers/tee/Makefile	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/tee/Makefile	2024-12-30 16:45:09.516525847 +0800
+@@ -5,3 +5,4 @@ tee-objs += tee_shm.o
+ tee-objs += tee_shm_pool.o
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/core.c linux-6.6.68/drivers/tee/mbedtee/core.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/core.c	2024-12-30 16:45:09.517525847 +0800
+@@ -0,0 +1,253 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/Kconfig linux-6.6.68/drivers/tee/mbedtee/Kconfig
+--- linux-6.6.68-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/Kconfig	2024-12-30 16:45:09.517525847 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/Makefile linux-6.6.68/drivers/tee/mbedtee/Makefile
+--- linux-6.6.68-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/Makefile	2024-12-30 16:45:09.517525847 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-6.6.68/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-6.6.68-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/mbedtee_drv.h	2024-12-30 16:47:54.533303136 +0800
+@@ -0,0 +1,154 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/syscalls.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-6.6.68/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-6.6.68-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/mbedtee_rpc.h	2024-12-30 16:45:09.517525847 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/rpc.c linux-6.6.68/drivers/tee/mbedtee/rpc.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/rpc.c	2024-12-30 16:45:09.517525847 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/rpc-callee.c linux-6.6.68/drivers/tee/mbedtee/rpc-callee.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/rpc-callee.c	2024-12-30 16:45:09.517525847 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-6.6.68/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/rpc-caller-arm.c	2024-12-30 16:45:09.518525847 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-6.6.68/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/rpc-caller-riscv.c	2024-12-30 16:45:09.518525847 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/shm_pool.c linux-6.6.68/drivers/tee/mbedtee/shm_pool.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/shm_pool.c	2024-12-30 16:45:09.518525847 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool *pool,
++			 struct tee_shm *shm, size_t size, size_t align)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_pool = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/shm_pool.h linux-6.6.68/drivers/tee/mbedtee/shm_pool.h
+--- linux-6.6.68-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/shm_pool.h	2024-12-30 16:45:09.518525847 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/mbedtee/supp.c linux-6.6.68/drivers/tee/mbedtee/supp.c
+--- linux-6.6.68-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.6.68/drivers/tee/mbedtee/supp.c	2024-12-30 16:45:09.518525847 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tee/tee_core.c linux-6.6.68/drivers/tee/tee_core.c
+--- linux-6.6.68-ori/drivers/tee/tee_core.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/tee/tee_core.c	2024-12-30 16:45:09.518525847 +0800
+@@ -575,8 +575,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/drivers/tty/serial/amba-pl011.c linux-6.6.68/drivers/tty/serial/amba-pl011.c
+--- linux-6.6.68-ori/drivers/tty/serial/amba-pl011.c	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/drivers/tty/serial/amba-pl011.c	2024-12-30 16:45:09.519525847 +0800
+@@ -2597,6 +2597,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2615,6 +2660,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.6.68-ori/include/uapi/linux/tee.h linux-6.6.68/include/uapi/linux/tee.h
+--- linux-6.6.68-ori/include/uapi/linux/tee.h	2024-12-27 20:58:58.000000000 +0800
++++ linux-6.6.68/include/uapi/linux/tee.h	2024-12-30 16:45:09.519525847 +0800
+@@ -57,6 +57,8 @@
+ #define TEE_IMPL_ID_OPTEE	1
+ #define TEE_IMPL_ID_AMDTEE	2
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.9.10.patch-- buildroot/tee/linux/linux-patches/mbedtee-linux-6.9.10.patch--
--- buildroot-ori/tee/linux/linux-patches/mbedtee-linux-6.9.10.patch--	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/linux-patches/mbedtee-linux-6.9.10.patch--	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,2149 @@
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/arch/arm/boot/compressed/head.S linux-6.9.10/arch/arm/boot/compressed/head.S
+--- linux-6.9.10-ori/arch/arm/boot/compressed/head.S	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/arch/arm/boot/compressed/head.S	2024-11-20 17:11:08.674744789 +0800
+@@ -309,7 +309,8 @@ not_angel:
+ 1:
+ #endif /* CONFIG_USE_OF */
+ 		/* Determine final kernel image address. */
+-		add	r4, r0, #TEXT_OFFSET
++		ldr	r4, =TEXT_OFFSET
++		add	r4, r0, r4
+ #else
+ 		ldr	r4, =zreladdr
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/arch/arm/kernel/head.S linux-6.9.10/arch/arm/kernel/head.S
+--- linux-6.9.10-ori/arch/arm/kernel/head.S	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/arch/arm/kernel/head.S	2024-11-20 17:11:08.677744789 +0800
+@@ -65,7 +65,8 @@ kernel_sec_end:
+ 	.popsection
+ 
+ 	.macro	pgtbl, rd, phys
+-	add	\rd, \phys, #TEXT_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	add	\rd, \phys, r0
+ 	sub	\rd, \rd, #PG_DIR_SIZE
+ 	.endm
+ 
+@@ -120,7 +121,9 @@ ENTRY(stext)
+ 
+ #ifndef CONFIG_XIP_KERNEL
+ 	adr_l	r8, _text			@ __pa(_text)
+-	sub	r8, r8, #TEXT_OFFSET		@ PHYS_OFFSET
++#	sub	r8, r8, #TEXT_OFFSET	@ PHYS_OFFSET
++	ldr 	r0, =TEXT_OFFSET
++	sub	r8, r8, r0				@ PHYS_OFFSET
+ #else
+ 	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
+ #endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/arch/arm/kernel/smp.c linux-6.9.10/arch/arm/kernel/smp.c
+--- linux-6.9.10-ori/arch/arm/kernel/smp.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/arch/arm/kernel/smp.c	2024-11-20 17:11:08.681744789 +0800
+@@ -65,20 +65,21 @@ enum ipi_msg_type {
+ 	IPI_CPU_STOP,
+ 	IPI_IRQ_WORK,
+ 	IPI_COMPLETION,
+-	NR_IPI,
+ 	/*
+ 	 * CPU_BACKTRACE is special and not included in NR_IPI
+ 	 * or tracable with trace_ipi_*
+ 	 */
+-	IPI_CPU_BACKTRACE = NR_IPI,
++	IPI_CPU_BACKTRACE,
+ 	/*
+ 	 * SGI8-15 can be reserved by secure firmware, and thus may
+ 	 * not be usable by the kernel. Please keep the above limited
+ 	 * to at most 8 entries.
+ 	 */
++	IPI_TEECALL,
++	NR_IPI,
+ 	MAX_IPI
+ };
+-
++extern void mbedtee_rpc_isr(void);
+ static int ipi_irq_base __read_mostly;
+ static int nr_ipi __read_mostly = NR_IPI;
+ static struct irq_desc *ipi_desc[MAX_IPI] __read_mostly;
+@@ -675,6 +676,11 @@ static void do_handle_IPI(int ipinr)
+ 		printk_deferred_exit();
+ 		break;
+ 
++	/* mbedtee callback */
++	case IPI_TEECALL:
++		mbedtee_rpc_isr();
++		break;
++
+ 	default:
+ 		pr_crit("CPU%u: Unknown IPI message 0x%x\n",
+ 		        cpu, ipinr);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/arch/arm/Makefile linux-6.9.10/arch/arm/Makefile
+--- linux-6.9.10-ori/arch/arm/Makefile	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/arch/arm/Makefile	2024-11-20 17:11:08.683744789 +0800
+@@ -151,7 +151,7 @@ CHECKFLAGS	+= -D__arm__
+ # Note: the 32kB below this value is reserved for use by the kernel
+ # during boot, and this offset is critical to the functioning of
+ # kexec-tools.
+-textofs-y	:= 0x00008000
++textofs-y	:= 0x06008000
+ # RTD1195 has Boot ROM at start of address space
+ textofs-$(CONFIG_ARCH_REALTEK)  := 0x00108000
+ # SA1111 DMA bug: we don't want the kernel to live in precious DMA-able memory
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/arch/arm64/kernel/smp.c linux-6.9.10/arch/arm64/kernel/smp.c
+--- linux-6.9.10-ori/arch/arm64/kernel/smp.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/arch/arm64/kernel/smp.c	2024-11-20 17:11:08.686744790 +0800
+@@ -74,6 +74,9 @@ enum ipi_msg_type {
+ 	IPI_CPU_CRASH_STOP,
+ 	IPI_TIMER,
+ 	IPI_IRQ_WORK,
++	IPI_RESERVED1,
++	IPI_RESERVED2, /* 0 ~ 7 for REE */
++	IPI_TEECALL, /* 8 ~ 15 for TEE */
+ 	NR_IPI,
+ 	/*
+ 	 * Any enum >= NR_IPI and < MAX_IPI is special and not tracable
+@@ -923,6 +926,11 @@ static void do_handle_IPI(int ipinr)
+ 		irq_work_run();
+ 		break;
+ #endif
++	/* mbedtee RPC callback */
++	case IPI_TEECALL:
++		extern void mbedtee_rpc_isr(void);
++		mbedtee_rpc_isr();
++		break;
+ 
+ 	case IPI_CPU_BACKTRACE:
+ 		/*
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/arch/riscv/kernel/sbi-ipi.c linux-6.9.10/arch/riscv/kernel/sbi-ipi.c
+--- linux-6.9.10-ori/arch/riscv/kernel/sbi-ipi.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/arch/riscv/kernel/sbi-ipi.c	2024-11-20 17:11:08.690744790 +0800
+@@ -15,6 +15,8 @@
+ 
+ static int sbi_ipi_virq;
+ 
++extern void mbedtee_rpc_isr(void);
++
+ static void sbi_ipi_handle(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+@@ -24,6 +26,8 @@ static void sbi_ipi_handle(struct irq_de
+ 	csr_clear(CSR_IP, IE_SIE);
+ 	ipi_mux_process();
+ 
++	mbedtee_rpc_isr();
++
+ 	chained_irq_exit(chip, desc);
+ }
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/firmware/psci/psci.c linux-6.9.10/drivers/firmware/psci/psci.c
+--- linux-6.9.10-ori/drivers/firmware/psci/psci.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/firmware/psci/psci.c	2024-11-20 17:11:08.693744790 +0800
+@@ -269,12 +269,14 @@ static unsigned long psci_migrate_info_u
+ 
+ static void set_conduit(enum arm_smccc_conduit conduit)
+ {
++	extern psci_fn mbedtee_rpc_fastcall;
++
+ 	switch (conduit) {
+ 	case SMCCC_CONDUIT_HVC:
+ 		invoke_psci_fn = __invoke_psci_fn_hvc;
+ 		break;
+ 	case SMCCC_CONDUIT_SMC:
+-		invoke_psci_fn = __invoke_psci_fn_smc;
++		invoke_psci_fn = mbedtee_rpc_fastcall;
+ 		break;
+ 	default:
+ 		WARN(1, "Unexpected PSCI conduit %d\n", conduit);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/irqchip/irq-gic.c linux-6.9.10/drivers/irqchip/irq-gic.c
+--- linux-6.9.10-ori/drivers/irqchip/irq-gic.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/irqchip/irq-gic.c	2024-11-20 17:11:08.695744790 +0800
+@@ -864,12 +864,15 @@ static __init void gic_smp_init(void)
+ 	cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,
+ 				  "irqchip/arm/gic:starting",
+ 				  gic_starting_cpu, NULL);
+-
+-	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ #else
+ #define gic_smp_init()		do { } while(0)
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/irqchip/irq-gic-v3.c linux-6.9.10/drivers/irqchip/irq-gic-v3.c
+--- linux-6.9.10-ori/drivers/irqchip/irq-gic-v3.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/irqchip/irq-gic-v3.c	2024-11-20 17:11:08.701744790 +0800
+@@ -1389,11 +1389,15 @@ static void __init gic_smp_init(void)
+ 				  gic_starting_cpu, NULL);
+ 
+ 	/* Register all 8 non-secure SGIs */
+-	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 8, NUMA_NO_NODE, &sgi_fwspec);
++	/*
++	 * SGI8-15 is current in use for mbedtee <-> linux IPI calls,
++	 * so install all 0 ~ 15 SGIs for mbedtee-client solution
++	 */
++	base_sgi = irq_domain_alloc_irqs(gic_data.domain, 16, NUMA_NO_NODE, &sgi_fwspec);
+ 	if (WARN_ON(base_sgi <= 0))
+ 		return;
+ 
+-	set_smp_ipi_range(base_sgi, 8);
++	set_smp_ipi_range(base_sgi, 16);
+ }
+ 
+ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/Kconfig linux-6.9.10/drivers/tee/Kconfig
+--- linux-6.9.10-ori/drivers/tee/Kconfig	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/tee/Kconfig	2024-11-20 17:11:08.707744791 +0800
+@@ -15,5 +15,6 @@ if TEE
+ 
+ source "drivers/tee/optee/Kconfig"
+ source "drivers/tee/amdtee/Kconfig"
++source "drivers/tee/mbedtee/Kconfig"
+ 
+ endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/Makefile linux-6.9.10/drivers/tee/Makefile
+--- linux-6.9.10-ori/drivers/tee/Makefile	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/tee/Makefile	2024-11-20 17:11:08.711744791 +0800
+@@ -5,3 +5,4 @@ tee-objs += tee_shm.o
+ tee-objs += tee_shm_pool.o
+ obj-$(CONFIG_OPTEE) += optee/
+ obj-$(CONFIG_AMDTEE) += amdtee/
++obj-$(CONFIG_MBEDTEE) += mbedtee/
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/core.c linux-6.9.10/drivers/tee/mbedtee/core.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/core.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/core.c	2024-11-20 17:40:59.106983959 +0800
+@@ -0,0 +1,253 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++#include <linux/tee_drv.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include "mbedtee_drv.h"
++#include "shm_pool.h"
++
++#include "../tee_private.h"
++
++struct mbedtee_clnt __clnt = {0}, *clnt = &__clnt;
++
++static void mbedtee_get_version(struct tee_device *teedev,
++			      struct tee_ioctl_version_data *vers)
++{
++	struct tee_ioctl_version_data v = {
++		.impl_id = TEE_IMPL_ID_MBEDTEE,
++		.impl_caps = 0,
++		.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM | TEE_GEN_CAP_MEMREF_NULL,
++	};
++
++	*vers = v;
++}
++
++static int mbedtee_open(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *ctxdata;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++
++	ctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);
++	if (!ctxdata)
++		return -ENOMEM;
++
++	mutex_init(&ctxdata->mutex);
++	INIT_LIST_HEAD(&ctxdata->sess_list);
++
++	dev_dbg(clnt->dev, "mbedtee_open\n");
++
++	ctx->data = ctxdata;
++	ctx->cap_memref_null = true;
++
++	return 0;
++}
++
++static void mbedtee_release(struct tee_context *ctx)
++{
++	struct mbedtee_context_data *d = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *s, *n = NULL;
++
++	if (d == NULL)
++		return;
++
++	if (d->is_supp_ctx)
++		mbedtee_supp_release(&clnt->supp);
++	else {
++		list_for_each_entry_safe(s, n, &d->sess_list, list_node) {
++			dev_dbg(clnt->dev, "mbedtee_release %d\n", s->session_id);
++			mbedtee_close_session(ctx, s->session_id);
++		}
++	}
++
++	kfree(d);
++	ctx->data = NULL;
++}
++
++static const struct tee_driver_ops mbedtee_ops = {
++	.get_version = mbedtee_get_version,
++	.open = mbedtee_open,
++	.release = mbedtee_release,
++	.open_session = mbedtee_open_session,
++	.close_session = mbedtee_close_session,
++	.invoke_func = mbedtee_invoke_session,
++	.cancel_req = mbedtee_cancel_req,
++	.supp_recv = mbedtee_supp_recv,
++	.supp_send = mbedtee_supp_send,
++	.shm_register = mbedtee_shm_register,
++	.shm_unregister = mbedtee_shm_unregister,
++};
++
++
++static const struct tee_desc mbedtee_desc = {
++	.name = "mbedtee-clnt",
++	.ops = &mbedtee_ops,
++	.owner = THIS_MODULE,
++};
++
++#if defined(MBEDTEE_NODE_IN_DTS)
++static int mbedtee_remove(struct platform_device *pdev)
++{
++	struct mbedtee_clnt *clnt = platform_get_drvdata(pdev);
++
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++
++	return 0;
++}
++
++static int mbedtee_probe(struct platform_device *pdev)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	dev_info(&pdev->dev, "mbedtee client probing\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		dev_info(&pdev->dev, "mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	dev_info(&pdev->dev, "mbedtee version: 0x%06x\n", version);
++	dev_info(&pdev->dev, "mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &pdev->dev;
++
++	platform_set_drvdata(pdev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client probed\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++
++	return ret;
++}
++
++static const struct of_device_id mbedtee_dt_match[] = {
++	{ .compatible = "mbedtee-clnt" },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, mbedtee_dt_match);
++
++static struct platform_driver mbedtee_driver = {
++	.probe  = mbedtee_probe,
++	.remove = mbedtee_remove,
++	.driver = {
++		.name = "mbedtee-clnt",
++		.of_match_table = mbedtee_dt_match,
++	},
++};
++module_platform_driver(mbedtee_driver);
++#endif
++
++static void __exit mbedtee_exit(void)
++{
++	mbedtee_supp_uninit(&clnt->supp);
++	tee_device_unregister(clnt->teedev);
++	tee_shm_pool_free(clnt->pool);
++}
++
++static int __init mbedtee_init(void)
++{
++	int ret = -1, version = 0, yield = false;
++	struct tee_shm_pool *pool = ERR_PTR(-EINVAL);
++	struct mbedtee_clnt *mbedclnt = clnt;
++	struct tee_device *teedev;
++
++	pr_info("mbedtee client init\n");
++
++	mbedtee_supp_init(&mbedclnt->supp);
++	mbedtee_rpc_init();
++
++	version = mbedtee_rpc_fastcall(RPC_OS_VERSION, 0, 0, 0);
++	if (!(MBEDTEE_VALID_VERSION(version))) {
++		pr_info("mbedtee not present 0x%x??\n", version);
++		return version;
++	}
++
++	yield = mbedtee_rpc_fastcall(RPC_SUPPORT_YIELD, 0, 0, 0);
++
++	pr_info("mbedtee version: 0x%06x\n", version);
++	pr_info("mbedtee yieldcall support: %d\n", yield);
++
++	pool = mbedtee_shm_pool_alloc_pages();
++	if (IS_ERR_OR_NULL(pool))
++		return -EINVAL;
++
++	teedev = tee_device_alloc(&mbedtee_desc, NULL, pool, mbedclnt);
++	if (IS_ERR(teedev)) {
++		ret = PTR_ERR(teedev);
++		goto out;
++	}
++	mbedclnt->teedev = teedev;
++
++	ret = tee_device_register(mbedclnt->teedev);
++	if (ret != 0)
++		goto out;
++
++	mbedclnt->version = version;
++	mbedclnt->yield = yield;
++	mbedclnt->pool = pool;
++	mbedclnt->dev = &teedev->dev;
++
++	dev_set_drvdata(mbedclnt->dev, mbedclnt);
++
++	dev_info(mbedclnt->dev, "mbedtee client initialized\n");
++	return 0;
++
++out:
++	if (teedev)
++		tee_device_unregister(teedev);
++	if (pool)
++		tee_shm_pool_free(pool);
++	return ret;
++}
++module_init(mbedtee_init);
++module_exit(mbedtee_exit);
++
++MODULE_AUTHOR("Kapa");
++MODULE_DESCRIPTION("MBEDTEE Client");
++MODULE_VERSION("1.0");
++MODULE_LICENSE("GPL v2");
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/Kconfig linux-6.9.10/drivers/tee/mbedtee/Kconfig
+--- linux-6.9.10-ori/drivers/tee/mbedtee/Kconfig	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/Kconfig	2024-11-20 17:11:08.713744791 +0800
+@@ -0,0 +1,8 @@
++# SPDX-License-Identifier: GPL-2.0-only
++# MBED-TEE Trusted Execution Environment Configuration
++config MBEDTEE
++	tristate "MBEDTEE"
++	depends on MMU
++	help
++	  This implements the MBEDTEE Trusted Execution Environment (TEE)
++	  driver.
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/Makefile linux-6.9.10/drivers/tee/mbedtee/Makefile
+--- linux-6.9.10-ori/drivers/tee/mbedtee/Makefile	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/Makefile	2024-11-20 17:11:08.713744791 +0800
+@@ -0,0 +1,13 @@
++# SPDX-License-Identifier: GPL-2.0
++
++ccflags-$(CONFIG_MBEDTEE) += -I$(STAGING_DIR)/usr/include/mbedtee
++
++obj-$(CONFIG_MBEDTEE) += mbedtee.o
++
++mbedtee-y += core.o
++mbedtee-y += supp.o
++mbedtee-y += shm_pool.o
++mbedtee-y += rpc.o rpc-callee.o
++mbedtee-$(CONFIG_ARM) += rpc-caller-arm.o
++mbedtee-$(CONFIG_ARM64) += rpc-caller-arm.o
++mbedtee-$(CONFIG_RISCV) += rpc-caller-riscv.o
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/mbedtee_drv.h linux-6.9.10/drivers/tee/mbedtee/mbedtee_drv.h
+--- linux-6.9.10-ori/drivers/tee/mbedtee/mbedtee_drv.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/mbedtee_drv.h	2024-11-20 17:11:08.714744791 +0800
+@@ -0,0 +1,154 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ */
++#ifndef MBEDTEE_DRV_H
++#define MBEDTEE_DRV_H
++
++#include <linux/types.h>
++#include <linux/of.h>
++#include <linux/semaphore.h>
++#include <linux/tee_drv.h>
++#include <linux/syscalls.h>
++#include <asm/cacheflush.h>
++
++#include <rpc/rpc.h>
++#include <rpc/reefs.h>
++
++#include "mbedtee_rpc.h"
++#include "shm_pool.h"
++
++#define TEEC_ERROR_TARGET_DEAD      0xFFFF3024
++#define TEEC_ERROR_OUT_OF_MEMORY    0xFFFF000C
++
++#define TEEC_ORIGIN_COMMS           0x00000002
++#define TEEC_ORIGIN_TEE             0x00000003
++
++#define MBEDTEE_VALID_VERSION(x) ((((x) >> 16) == 1) && \
++	((((x) >> 8) & 0xFF) >= 0) && (((x) & 0xFF) >= 1))
++
++struct mbedtee_supp {
++	struct mutex mutex;
++	struct tee_context *ctx;
++
++	void *req;
++	struct list_head reqs;
++	struct completion reqs_c;
++};
++
++struct mbedtee_clnt {
++	int version;
++	int yield;
++	struct device *dev;
++	struct tee_device *teedev;
++	struct tee_shm_pool *pool;
++	struct mbedtee_supp supp;
++};
++
++struct mbedtee_session {
++	struct list_head list_node;
++	u32 session_id;
++};
++
++struct mbedtee_context_data {
++	int is_supp_ctx;
++	struct mutex mutex;
++	struct list_head sess_list;
++};
++
++typedef struct {
++	uint32_t timeLow;
++	uint16_t timeMid;
++	uint16_t timeHiAndVersion;
++	uint8_t clockSeqAndNode[8];
++} TEEC_UUID;
++
++extern struct mbedtee_clnt *clnt;
++
++#define mbedtee_bswap16(_x) ((__u16)(((_x) >> 8) | (((_x) << 8) & 0xff00)))
++#define mbedtee_bswap32(_x) ((__u32)(((_x) >> 24) | (((_x) >> 8) & 0xff00) | \
++	    (((_x) << 8) & 0xff0000) | (((_x) << 24) & 0xff000000)))
++
++static inline void mbedtee_flush_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM)
++	__cpuc_flush_dcache_area(va, size);
++#endif
++
++#if defined(CONFIG_ARM64)
++	dcache_clean_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* wback & inv */
++	/* ALT_CMO_OP(FLUSH, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline void mbedtee_invalidate_cache(void *va, size_t size)
++{
++	/* currently unnecessary */
++	return;
++
++#if defined(CONFIG_ARM64)
++	dcache_inval_poc((long)va, (long)va + size);
++#endif
++
++#if defined(CONFIG_RISCV)
++	/* inv */
++	/* ALT_CMO_OP(INVAL, va, size, riscv_cbom_block_size); */
++#endif
++}
++
++static inline phys_addr_t mbedtee_virt_to_phys(void *va)
++{
++	if (is_vmalloc_or_module_addr(va)) {
++		return page_to_phys(vmalloc_to_page(va)) +
++				    offset_in_page(va);
++	}
++
++	WARN_ON(!virt_addr_valid(va));
++	return virt_to_phys(va);
++}
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size);
++void mbedtee_rpc_free(struct rpc_cmd *rpc);
++
++int mbedtee_open_session(struct tee_context *ctx,
++	struct tee_ioctl_open_session_arg *arg, struct tee_param *param);
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg, struct tee_param *param);
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session);
++
++int mbedtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start);
++
++int mbedtee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
++
++/* TEE->REE RPC */
++int mbedtee_rpc_init(void);
++void mbedtee_rpc_isr(void);
++
++void mbedtee_supp_init(struct mbedtee_supp *supp);
++void mbedtee_supp_uninit(struct mbedtee_supp *supp);
++void mbedtee_supp_release(struct mbedtee_supp *supp);
++int mbedtee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
++		    struct tee_param *param);
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param);
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size);
++
++/* REE->TEE RPC */
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible);
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2);
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/mbedtee_rpc.h linux-6.9.10/drivers/tee/mbedtee/mbedtee_rpc.h
+--- linux-6.9.10-ori/drivers/tee/mbedtee/mbedtee_rpc.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/mbedtee_rpc.h	2024-11-20 17:11:08.714744791 +0800
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ *
++ * Export symbols for other kernel modules
++ */
++#ifndef _MBEDTEE_RPC_H
++#define _MBEDTEE_RPC_H
++
++/*
++ * defines the __typeof__ the RPC callee function handler.
++ * @data - shared memory buffer from the RPC peer.
++ * @size - the data size of this shared memory buffer.
++ */
++typedef void (*rpc_func_t)(void *data, size_t size);
++
++/*
++ * register the rpc callee func.
++ * @id - function id of callee
++ * @return - 0 on success. Else negative num.
++ */
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func);
++
++/*
++ * unregister the callee @id.
++ */
++void mbedtee_unregister_rpc(unsigned int id);
++
++#endif
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/rpc.c linux-6.9.10/drivers/tee/mbedtee/rpc.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/rpc.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/rpc.c	2024-11-20 17:57:25.873893672 +0800
+@@ -0,0 +1,396 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RPC calls to TEE
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++struct rpc_cmd *mbedtee_rpc_alloc(size_t size)
++{
++	struct page *p = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	if (sizeof(struct rpc_cmd) + size > PAGE_SIZE)
++		return NULL;
++
++	p = alloc_page(GFP_KERNEL);
++	if (p == NULL)
++		return NULL;
++
++	rpc = kmap(p);
++	rpc->size = size;
++	rpc->ret = -1;
++	rpc->interrupted = 0;
++
++	return rpc;
++}
++EXPORT_SYMBOL(mbedtee_rpc_alloc);
++
++void mbedtee_rpc_free(struct rpc_cmd *rpc)
++{
++	struct page *p = NULL;
++
++	if (rpc && (!rpc->interrupted)) {
++		p = virt_to_page(rpc);
++		kunmap(p);
++		put_page(p);
++	}
++}
++EXPORT_SYMBOL(mbedtee_rpc_free);
++
++static int mbedtee_param_decode(struct tee_param *params,
++	size_t num_params, const struct rpc_param *rp)
++{
++	size_t n;
++#define TYPE_GET(t, i) ((((uint32_t)t) >> ((i)*4)) & 0xF)
++
++	for (n = 0; n < num_params; n++) {
++		struct tee_param *p = params + n;
++		const union rpc_tee_param *rtp = rp->params + n;
++		u32 attr = TYPE_GET(rp->params_type, n);
++
++		switch (attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(&p->u, 0, sizeof(p->u));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			p->u.value.a = rtp->value.a;
++			p->u.value.b = rtp->value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			p->u.memref.size = rtp->memref.size;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int mbedtee_param_encode(struct rpc_param *rp,
++	size_t num_params, const struct tee_param *params)
++{
++	size_t n;
++#define TYPE_SET(t, i) (((uint32_t)(t) & 0xF) << ((i)*4))
++
++	rp->params_type = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
++
++	for (n = 0; n < num_params; n++) {
++		const struct tee_param *p = params + n;
++		union rpc_tee_param *rtp = rp->params + n;
++
++		rp->params_type |= TYPE_SET(p->attr, n);
++
++		switch (p->attr) {
++		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
++			memset(rtp, 0, sizeof(*rtp));
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
++			rtp->value.a = p->u.value.a;
++			rtp->value.b = p->u.value.b;
++			break;
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
++		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
++			if (p->u.memref.shm)
++				rtp->memref.id = p->u.memref.shm->sec_world_id;
++			else
++				rtp->memref.id = 0; /* invalid-id @ mbedtee */
++			rtp->memref.size = p->u.memref.size;
++			rtp->memref.offset = p->u.memref.shm_offs;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static void mbedtee_errno_origin(
++	__u32 *errno, __u32 *origin)
++{
++	switch (*errno) {
++	case -ENOMEM:
++		*errno = TEEC_ERROR_OUT_OF_MEMORY;
++		break;
++	case -ESRCH:
++		*origin = TEEC_ORIGIN_TEE;
++		*errno = TEEC_ERROR_TARGET_DEAD;
++		break;
++	default:
++		break;
++	}
++}
++
++static struct mbedtee_session *mbedtee_session_of(
++	struct mbedtee_context_data *ctxdata,
++	u32 session_id)
++{
++	struct mbedtee_session *sess, *ret = NULL;
++
++	mutex_lock(&ctxdata->mutex);
++	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
++		if (sess->session_id == session_id) {
++			ret = sess;
++			break;
++		}
++	mutex_unlock(&ctxdata->mutex);
++	return ret;
++}
++
++int mbedtee_open_session(struct tee_context *ctx,
++			   struct tee_ioctl_open_session_arg *arg,
++			   struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret != 0) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
++	if (sess == NULL) {
++		mbedtee_rpc_free(rpc);
++		return -ENOMEM;
++	}
++
++	memcpy(rp->uuid, arg->uuid, sizeof(arg->uuid));
++	memcpy(rp->clnt_uuid, arg->clnt_uuid, sizeof(arg->clnt_uuid));
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_rpc_yieldcall(RPC_OPEN_SESSION, rpc, false);
++
++	dev_dbg(clnt->dev, "open session ret %d\n", ret);
++
++	if (ret == 0) {
++		sess->session_id = rp->session_id;
++		mutex_lock(&ctxdata->mutex);
++		list_add(&sess->list_node, &ctxdata->sess_list);
++		mutex_unlock(&ctxdata->mutex);
++
++		mbedtee_param_decode(param, arg->num_params, rp);
++	} else {
++		kfree(sess);
++	}
++
++	arg->session = rp->session_id;
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_invoke_session(struct tee_context *ctx,
++	struct tee_ioctl_invoke_arg *arg,
++	struct tee_param *param)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct mbedtee_session *sess;
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++
++	sess = mbedtee_session_of(ctxdata, arg->session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = arg->session;
++	rp->cmd_id = arg->func;
++	rp->ret_origin = TEEC_ORIGIN_COMMS;
++
++	ret = mbedtee_param_encode(rp, arg->num_params, param);
++	if (ret) {
++		mbedtee_rpc_free(rpc);
++		return ret;
++	}
++
++	ret = mbedtee_rpc_yieldcall(RPC_INVOKE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "invoke session ret %d\n", ret);
++
++	mbedtee_param_decode(param, arg->num_params, rp);
++
++	arg->ret = ret;
++	arg->ret_origin = rp->ret_origin;
++	mbedtee_errno_origin(&arg->ret, &arg->ret_origin);
++
++	mbedtee_rpc_free(rpc);
++	return 0;
++}
++
++int mbedtee_close_session(struct tee_context *ctx, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	struct rpc_cmd *rpc = NULL;
++	struct rpc_param *rp = NULL;
++	struct mbedtee_session *sess = NULL;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*rp));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	rp = (struct rpc_param *)rpc->data;
++
++	rp->session_id = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CLOSE_SESSION, rpc, true);
++
++	dev_dbg(clnt->dev, "close session ret %d\n", ret);
++
++	mutex_lock(&ctxdata->mutex);
++	list_del(&sess->list_node);
++	kfree(sess);
++	mutex_unlock(&ctxdata->mutex);
++
++	mbedtee_rpc_free(rpc);
++
++	/*
++	 * ESRCH means the session already been closed in
++	 * mbedtee, so REE return success for this case
++	 */
++	return (ret == -ESRCH) ? 0 : ret;
++}
++
++int mbedtee_cancel_req(struct tee_context *ctx,
++	u32 cancel_id, u32 session)
++{
++	int ret = -1;
++	struct mbedtee_context_data *ctxdata = ctx->data;
++	struct mbedtee_session *sess = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(int));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	sess = mbedtee_session_of(ctxdata, session);
++	if (sess == NULL)
++		return -EINVAL;
++
++	*(int *)rpc->data = session;
++
++	ret = mbedtee_rpc_yieldcall(RPC_CANCEL, rpc, false);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
++int mbedtee_shm_register(struct tee_context *ctx,
++	struct tee_shm *shm, struct page **pages,
++	size_t nr_pages, unsigned long start)
++{
++	int ret = -1, i = 0, j = 0;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++	unsigned long *pagearray = NULL;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(ctx->teedev);
++	size_t pagearray_sz = 0, multiple = PAGE_SIZE / TEE_PAGE_SIZE;
++
++	dev_dbg(clnt->dev, "nr_pages %d @ %d\n", (int)nr_pages, shm->id);
++
++	BUILD_BUG_ON(multiple == 0);
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++
++	pagearray_sz = DIV_ROUND_UP(nr_pages * sizeof(long) * multiple, PAGE_SIZE);
++	pagearray = alloc_pages_exact(pagearray_sz, GFP_KERNEL);
++	if (pagearray == NULL) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	for (i = 0; i < nr_pages; i++) {
++		for (j = 0; j < multiple; j++)
++			pagearray[i * multiple + j] = TEE_PAGE_SIZE * j + \
++				page_to_phys(pages[i]);
++	}
++
++	memref->size = tee_shm_get_size(shm);
++	memref->offset = tee_shm_get_page_offset(shm);
++	memref->pages = mbedtee_virt_to_phys(pagearray);
++	memref->cnt = nr_pages * multiple;
++
++	ret = mbedtee_rpc_yieldcall(RPC_REGISTER_SHM, rpc, false);
++
++	if (ret == 0)
++		shm->sec_world_id = memref->id;
++
++	free_pages_exact(pagearray, pagearray_sz);
++
++out:
++	mbedtee_rpc_free(rpc);
++	return ret;
++}
++
++int mbedtee_shm_unregister(struct tee_context *ctx,
++	struct tee_shm *shm)
++{
++	int ret = -1;
++	struct rpc_memref *memref = NULL;
++	struct rpc_cmd *rpc = NULL;
++
++	rpc = mbedtee_rpc_alloc(sizeof(*memref));
++	if (rpc == NULL)
++		return -ENOMEM;
++
++	memref = (struct rpc_memref *)rpc->data;
++	memref->id = shm->sec_world_id;
++
++	ret = mbedtee_rpc_yieldcall(RPC_UNREGISTER_SHM, rpc, true);
++
++	mbedtee_rpc_free(rpc);
++
++	return ret;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/rpc-callee.c linux-6.9.10/drivers/tee/mbedtee/rpc-callee.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/rpc-callee.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/rpc-callee.c	2024-11-20 17:11:08.714744791 +0800
+@@ -0,0 +1,299 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2020, Kapa Limited
++ * Callees for TEE->REE RPC
++ */
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/printk.h>
++#include <asm/smp.h>
++#include <asm/cacheflush.h>
++#include <asm/hardirq.h>
++#include <linux/delay.h>
++#include <linux/highmem.h>
++
++#include <rpc/rpc.h>
++
++#include "mbedtee_drv.h"
++
++static void *t2r_shm = NULL;
++static unsigned long t2r_shm_phys = 0;
++static struct rpc_ringbuf *t2r_ring = NULL;
++static unsigned int t2r_ring_sz = 0;
++static unsigned int t2r_ring_rd = 0;
++static unsigned char __rpc_data[PAGE_SIZE] = {0};
++static rpc_func_t __rpc_callee_funcs[RPC_REENR] = {NULL};
++
++static DEFINE_SPINLOCK(__rpc_lock);
++
++struct mbedtee_rpc_work {
++	pid_t waiter;
++	int unfinish;
++	void *data;
++	unsigned int size;
++	rpc_func_t func;
++	struct work_struct work;
++};
++
++static inline size_t mbedtee_rpc_available_size(void)
++{
++	unsigned int wr = 0;
++	unsigned int rd = t2r_ring_rd;
++	unsigned int shm_size = t2r_ring_sz;
++
++	wr = t2r_ring->wr;
++	smp_rmb();
++
++	if (wr > shm_size)
++		return 0;
++
++	if (wr >= rd)
++		return wr - rd;
++	else
++		return shm_size + wr - rd;
++}
++
++static inline void mbedtee_rpc_read(void *data, size_t size)
++{
++	unsigned int remain = 0;
++	unsigned int shm_size = t2r_ring_sz;
++	unsigned int rd = t2r_ring_rd;
++	struct rpc_ringbuf *shm = t2r_ring;
++
++	smp_wmb();
++	if (rd + size <= shm_size) {
++		mbedtee_invalidate_cache(&shm->mem[rd], size);
++		memcpy(data, &shm->mem[rd], size);
++		rd += size;
++	} else {
++		remain = rd + size - shm_size;
++		mbedtee_invalidate_cache(&shm->mem[rd], size - remain);
++		memcpy(data, &shm->mem[rd], size - remain);
++		mbedtee_invalidate_cache(&shm->mem[0], remain);
++		memcpy((unsigned char *)data + size - remain,
++				&shm->mem[0], remain);
++		rd = remain;
++	}
++
++	shm->rd = t2r_ring_rd = rd;
++
++	smp_rmb();
++}
++
++static struct mbedtee_rpc_work *mbedtee_rpc_pick_next(
++	struct mbedtee_rpc_work *c)
++{
++	unsigned long retry = 0;
++	struct rpc_cmd cmd = {0};
++	rpc_func_t func = NULL;
++
++	/* handle the last unfinished rpc */
++	if (c->unfinish) {
++		if (mbedtee_rpc_available_size() < c->size)
++			return NULL;
++		c->unfinish = false;
++		mbedtee_rpc_read((void *)c->data, c->size);
++		return c;
++	}
++
++	if (mbedtee_rpc_available_size() < sizeof(cmd))
++		return NULL;
++
++	mbedtee_rpc_read(&cmd, sizeof(cmd));
++
++	if (cmd.id >= RPC_REENR)
++		return NULL;
++
++	func = __rpc_callee_funcs[cmd.id];
++	if (func == NULL) {
++		pr_emerg("rpc unregister %d ??\n", cmd.id);
++		return NULL;
++	}
++
++	if (cmd.waiter == 0) {
++ 		/* async rpc notification from peer */
++		while (mbedtee_rpc_available_size() < cmd.size) {
++			if (++retry % 1000 == 0)
++				pr_emerg("rpc retrying for %d func %d\n", cmd.size, cmd.id);
++			if (retry == 5000) {
++				/* mark as unfinished rpc */
++				c->unfinish = true;
++				return NULL;
++			}
++			udelay(5);
++		}
++		mbedtee_rpc_read(c->data, cmd.size);
++	} else {
++		if (cmd.shm == 0) {
++			pr_emerg("rpc cmd.shm error ??\n");
++			return NULL;
++		}
++
++		/* sync rpc notification from peer */
++		c = kmalloc(sizeof(*c), GFP_ATOMIC);
++		c->data = t2r_shm + (cmd.shm - t2r_shm_phys);
++	}
++
++	c->func = func;
++	c->waiter = cmd.waiter;
++	c->size = cmd.size;
++
++	return c;
++}
++
++static void rpc_routine(struct work_struct *w)
++{
++	struct mbedtee_rpc_work *c = NULL;
++
++	c = container_of(w, struct mbedtee_rpc_work, work);
++
++	c->func(c->data, c->size);
++
++	mbedtee_flush_cache(c->data, c->size);
++
++	mbedtee_rpc_fastcall(RPC_COMPLETE_TEE, c->waiter, 0, 0);
++	kfree(c);
++}
++
++extern void mbedtee_rpc_isr(void)
++{
++	unsigned long flags = 0, retry = 0;
++	struct mbedtee_rpc_work rw = {0}, *c = &rw;
++	struct rpc_ringbuf *ring = t2r_ring;
++
++	if (!ring || (t2r_ring_rd == ring->wr))
++		return;
++
++	c->data = (void *)__rpc_data;
++	spin_lock_irqsave(&__rpc_lock, flags);
++	while (t2r_ring_rd != ring->wr) {
++		if ((c = mbedtee_rpc_pick_next(&rw)) == NULL) {
++			if (++retry == 5000)
++				break;
++			continue;
++		}
++
++		/* no peer is waiting, it's asynchronous rpc */
++		if (c->waiter == 0) {
++			c->func(c->data, c->size);
++		} else {
++			/* peer is waiting, it's synchronous rpc */
++			INIT_WORK(&c->work, rpc_routine);
++			queue_work_on(smp_processor_id(), system_highpri_wq, &c->work);
++		}
++	}
++	spin_unlock_irqrestore(&__rpc_lock, flags);
++
++	if (retry)
++		pr_emerg("retry %ld\n", retry);
++}
++
++static struct rpc_cmd *__mbedtee_rpc_get_cmd(
++	void *data, size_t size)
++{
++	unsigned long cmd_phy = 0;
++
++	memcpy(&cmd_phy, data, sizeof(cmd_phy));
++
++	return phys_to_virt(cmd_phy);
++}
++
++/*
++ * Internal RPC instance to complete the rpc call
++ */
++static void mbedtee_rpc_complete(void *data, size_t size)
++{
++	struct rpc_cmd *cmd = __mbedtee_rpc_get_cmd(data, size);
++
++	if (!cmd || !cmd->waiter)
++		return;
++
++	smp_rmb();
++	if (!cmd->interrupted)
++		complete((void *)cmd->waiter);
++	else {
++		struct page *p = virt_to_page(cmd);
++		kunmap(p);
++		put_page(p);
++	}
++}
++
++static void mbedtee_ree_time(void *data, size_t size)
++{
++	struct timespec64 *ts = (void *)data;
++
++	ktime_get_real_ts64(ts);
++}
++
++static void mbedtee_reefs_supp(void *data, size_t size)
++{
++	mbedtee_supp_handler(clnt, SUPP_REEFS, data, size);
++}
++
++int mbedtee_register_rpc(unsigned int id, rpc_func_t func)
++{
++	if (id >= RPC_REENR || !func)
++		return -EINVAL;
++
++	__rpc_callee_funcs[id] = func;
++
++	return 0;
++}
++EXPORT_SYMBOL(mbedtee_register_rpc);
++
++void mbedtee_unregister_rpc(unsigned int id)
++{
++	if (id >= RPC_REENR)
++		return;
++
++	__rpc_callee_funcs[id] = NULL;
++}
++EXPORT_SYMBOL(mbedtee_unregister_rpc);
++
++int mbedtee_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-t2r-shm", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	t2r_shm_phys = of_read_ulong(range, naddr);
++	t2r_shm = ioremap(t2r_shm_phys,
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_shm)
++		t2r_shm = phys_to_virt(t2r_shm_phys);
++
++	pr_info("rpc-t2r-shm %lx\n", t2r_shm_phys);
++
++	range = of_get_property(dn, "rpc-t2r-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("rpc-t2r-ring %lx\n", of_read_ulong(range, naddr));
++
++	t2r_ring_sz = of_read_ulong(range + naddr, nsize) -
++			sizeof(struct rpc_ringbuf);
++
++	t2r_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++	if (!t2r_ring)
++		t2r_ring = phys_to_virt(of_read_ulong(range, naddr));
++
++	mbedtee_register_rpc(RPC_REEFS, mbedtee_reefs_supp);
++	mbedtee_register_rpc(RPC_REETIME, mbedtee_ree_time);
++	mbedtee_register_rpc(RPC_COMPLETE_REE, mbedtee_rpc_complete);
++
++	return 0;
++}
++
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/rpc-caller-arm.c linux-6.9.10/drivers/tee/mbedtee/rpc-caller-arm.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/rpc-caller-arm.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/rpc-caller-arm.c	2024-11-20 17:11:08.714744791 +0800
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * ARM RPC calls to TEE - relies on SMC
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static inline long trigger_smc(unsigned long rpc)
++{
++	long ret = 0;
++
++#ifdef CONFIG_ARM
++	register long r0 asm ("r0") = rpc;
++	smp_wmb();
++	asm volatile(".arch_extension sec\n"
++				"smc 0x0" : "=r" (ret) : "r" (r0): "memory", "cc");
++#endif
++
++#ifdef CONFIG_ARM64
++	register long x0 asm ("x0") = rpc;
++	smp_wmb();
++	asm volatile("smc 0x0" : "=r" (ret) : "r" (x0) : "memory", "cc");
++#endif
++
++	return ret;
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret)
++		return ret;
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	static long buff[CONFIG_NR_CPUS][((sizeof(struct rpc_cmd)\
++		/ sizeof(long)) + 4)] __attribute__ ((aligned (64))) = {0};
++	struct rpc_cmd *rpc = NULL;
++	unsigned long flags = 0;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	local_irq_save(flags);
++
++	rpc = (struct rpc_cmd *)buff[smp_processor_id()];
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	ret = trigger_smc(mbedtee_virt_to_phys(rpc));
++	if (ret == 0)
++		ret = rpc->ret;
++
++	local_irq_restore(flags);
++
++	return ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/rpc-caller-riscv.c linux-6.9.10/drivers/tee/mbedtee/rpc-caller-riscv.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/rpc-caller-riscv.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/rpc-caller-riscv.c	2024-11-20 17:11:08.714744791 +0800
+@@ -0,0 +1,234 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright 2020, Kapa Limited
++ * RISCV RPC calls to TEE - relies on IPI (sswi)
++ */
++#include <linux/mm.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/highmem.h>
++
++#include "mbedtee_drv.h"
++
++static DEFINE_SPINLOCK(rpc_lock);
++static struct rpc_ringbuf *r2t_ring = NULL;
++static unsigned int r2t_ring_sz = 0;
++static void *sswi_base = NULL;
++
++static int r2t_rpc_init(void)
++{
++	int ret = -1, naddr = 0, nsize = 0, plen = 0;
++	struct device_node *dn = NULL;
++	const __be32 *range = NULL;
++
++	dn = of_find_node_by_name(NULL, "memory");
++	if (!dn)
++		return ret;
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "rpc-r2t-ring", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize)) {
++		pr_info("lack of rpc-r2t-ring\n");
++		return ret;
++	}
++
++	pr_info("rpc-r2t-ring %lx\n", of_read_ulong(range, naddr));
++
++	r2t_ring = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	r2t_ring_sz = of_read_ulong(range + naddr, nsize) -
++				sizeof(struct rpc_ringbuf);
++
++	dn = of_find_compatible_node(NULL, NULL, "riscv,aclint-sswi");
++	if (!dn) {
++		pr_info("lack of riscv,aclint-sswi\n");
++		return ret;
++	}
++
++	naddr = of_n_addr_cells(dn);
++	nsize = of_n_size_cells(dn);
++
++	range = of_get_property(dn, "reg", &plen);
++	if (range == NULL || (plen/sizeof(u32) != naddr + nsize))
++		return ret;
++
++	pr_info("riscv,aclint-sswi %lx\n", of_read_ulong(range, naddr));
++
++	sswi_base = ioremap(of_read_ulong(range, naddr),
++			of_read_ulong(range + naddr, nsize));
++
++	return 0;
++}
++
++/*
++ * check if the remain ring-buff is
++ * enough or not for current call
++ */
++static int rpc_ring_enough(unsigned int size)
++{
++	unsigned int wr = 0, rd = 0;
++	unsigned int remain = 0,ringsz = r2t_ring_sz;
++	struct rpc_ringbuf *shm = r2t_ring;
++
++	wr = shm->wr;
++	rd = shm->rd;
++	smp_rmb();
++
++	if ((rd > ringsz) || (wr > ringsz))
++		return false;
++
++	if (rd <= wr)
++		remain = ringsz + rd - wr;
++	else
++		remain = rd - wr;
++
++	return remain >= size;
++}
++
++/*
++ * copy into the ring-buff,
++ * and update the write ptr
++ */
++static void rpc_ring_write(void *data, unsigned int size)
++{
++	struct rpc_ringbuf *shm = r2t_ring;
++	unsigned int remain = 0, ringsz = r2t_ring_sz;
++	static unsigned int wr = 0;
++
++	if (wr + size > ringsz) {
++		remain = wr + size - ringsz;
++		memcpy(&shm->mem[wr], data, size - remain);
++		mbedtee_flush_cache(&shm->mem[wr], size - remain);
++		memcpy(&shm->mem[0], data + size - remain, remain);
++		mbedtee_flush_cache(&shm->mem[0], remain);
++		wr = remain;
++	} else {
++		memcpy(&shm->mem[wr], data, size);
++		mbedtee_flush_cache(&shm->mem[wr], size);
++		wr += size;
++	}
++
++	shm->wr = wr;
++
++	smp_mb();
++}
++
++static void trigger_sswi(void)
++{
++	iowrite32(1, (int *)sswi_base + 0);
++}
++
++long mbedtee_rpc_yieldcall(unsigned long fn, struct rpc_cmd *rpc, int interruptible)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	if (interruptible) {
++		ret = wait_for_completion_interruptible(&c);
++		if (ret) {
++			rpc->interrupted = true;
++			return ret;
++		}
++	} else wait_for_completion(&c);
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_yieldcall);
++
++long mbedtee_rpc_fastcall(unsigned long fn, unsigned long a0,
++	unsigned long a1, unsigned long a2)
++{
++	long ret = -1;
++	struct completion c = {0};
++	unsigned long flags = 0;
++	long buff[((sizeof(struct rpc_cmd)/sizeof(long)) + 4)] = {0};
++	struct rpc_cmd *rpc = (void *)buff;
++	unsigned long phys = 0;
++
++	if (!r2t_ring)
++		r2t_rpc_init();
++
++	if (!r2t_ring)
++		return -ENXIO;
++
++	if (!RPC_IS_FASTCALL(fn))
++		return -EINVAL;
++
++	rpc->ret = -ENOSYS;
++	rpc->waiter = (unsigned long)&c;
++
++	init_completion(&c);
++
++	spin_lock_irqsave(&rpc_lock, flags);
++	if (!rpc_ring_enough(sizeof(long))) {
++		pr_emerg("rpc ring not enough\n");
++		spin_unlock_irqrestore(&rpc_lock, flags);
++		return -ENOMEM;
++	}
++
++	rpc->id = fn;
++	rpc->ret = -ENOSYS;
++
++	/* 3 args */
++	rpc->size = 3 * sizeof(long);
++	rpc->data[0] = a0;
++	rpc->data[1] = a1;
++	rpc->data[2] = a2;
++
++	mbedtee_flush_cache(rpc, sizeof(*rpc) + rpc->size);
++
++	phys = mbedtee_virt_to_phys(rpc);
++	rpc_ring_write((void *)&phys, sizeof(phys));
++
++	trigger_sswi();
++
++	spin_unlock_irqrestore(&rpc_lock, flags);
++
++	ret = wait_for_completion_interruptible(&c);
++	if (ret)
++		return ret;
++
++	return rpc->ret;
++}
++EXPORT_SYMBOL(mbedtee_rpc_fastcall);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/shm_pool.c linux-6.9.10/drivers/tee/mbedtee/shm_pool.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/shm_pool.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/shm_pool.c	2024-11-20 17:11:08.715744791 +0800
+@@ -0,0 +1,86 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2017, EPAM Systems
++ */
++#include <linux/device.h>
++#include <linux/dma-buf.h>
++#include <linux/genalloc.h>
++#include <linux/slab.h>
++
++#include "mbedtee_drv.h"
++
++static int pool_op_alloc(struct tee_shm_pool *pool,
++			 struct tee_shm *shm, size_t size, size_t align)
++{
++	unsigned int order = get_order(size);
++	struct page *page;
++	int rc = 0;
++
++	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
++	if (!page)
++		return -ENOMEM;
++
++	shm->kaddr = page_address(page);
++	shm->paddr = page_to_phys(page);
++	shm->size = PAGE_SIZE << order;
++
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield) {
++		unsigned int nr_pages = 1 << order, i;
++		struct page **pages;
++
++		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
++		if (!pages)
++			return -ENOMEM;
++
++		for (i = 0; i < nr_pages; i++) {
++			pages[i] = page;
++			page++;
++		}
++
++		rc = mbedtee_shm_register(shm->ctx, shm, pages, nr_pages,
++					(unsigned long)shm->kaddr);
++		kfree(pages);
++	}
++
++	return rc;
++}
++
++static void pool_op_free(struct tee_shm_pool *pool,
++			 struct tee_shm *shm)
++{
++	if (!(shm->flags & TEE_SHM_PRIV) && clnt->yield)
++		mbedtee_shm_unregister(shm->ctx, shm);
++
++	free_pages((unsigned long)shm->kaddr, get_order(shm->size));
++	shm->kaddr = NULL;
++}
++
++static void pool_op_destroy_pool(struct tee_shm_pool *pool)
++{
++	kfree(pool);
++}
++
++static const struct tee_shm_pool_ops pool_ops = {
++	.alloc = pool_op_alloc,
++	.free = pool_op_free,
++	.destroy_pool = pool_op_destroy_pool,
++};
++
++/**
++ * mbedtee_shm_pool_alloc_pages() - create page-based allocator pool
++ *
++ * This pool is used when MBEDTEE supports dymanic SHM. In this case
++ * command buffers and such are allocated from kernel's own memory.
++ */
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void)
++{
++	struct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);
++
++	if (!pool)
++		return ERR_PTR(-ENOMEM);
++
++	pool->ops = &pool_ops;
++
++	return pool;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/shm_pool.h linux-6.9.10/drivers/tee/mbedtee/shm_pool.h
+--- linux-6.9.10-ori/drivers/tee/mbedtee/shm_pool.h	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/shm_pool.h	2024-11-20 17:11:08.715744791 +0800
+@@ -0,0 +1,14 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (c) 2015, Linaro Limited
++ * Copyright (c) 2016, EPAM Systems
++ */
++
++#ifndef SHM_POOL_H
++#define SHM_POOL_H
++
++#include <linux/tee_drv.h>
++
++struct tee_shm_pool *mbedtee_shm_pool_alloc_pages(void);
++
++#endif
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/mbedtee/supp.c linux-6.9.10/drivers/tee/mbedtee/supp.c
+--- linux-6.9.10-ori/drivers/tee/mbedtee/supp.c	1970-01-01 08:00:00.000000000 +0800
++++ linux-6.9.10/drivers/tee/mbedtee/supp.c	2024-11-20 17:11:08.715744791 +0800
+@@ -0,0 +1,210 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2015, Linaro Limited
++ */
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/highmem.h>
++#include <asm/cacheflush.h>
++
++#include "mbedtee_drv.h"
++
++struct mbedtee_supp_req {
++	int ret;
++	u32 func;
++
++	struct list_head node;
++
++	struct tee_shm *shm;
++	void *data;
++	size_t size;
++
++	struct completion c;
++};
++
++void mbedtee_supp_init(struct mbedtee_supp *supp)
++{
++	memset(supp, 0, sizeof(*supp));
++	mutex_init(&supp->mutex);
++	init_completion(&supp->reqs_c);
++	INIT_LIST_HEAD(&supp->reqs);
++}
++
++void mbedtee_supp_uninit(struct mbedtee_supp *supp)
++{
++	mutex_destroy(&supp->mutex);
++}
++
++void mbedtee_supp_release(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *r, *n;
++
++	mutex_lock(&supp->mutex);
++
++	list_for_each_entry_safe(r, n, &supp->reqs, node) {
++		list_del(&r->node);
++		r->ret = -ERESTARTSYS;
++		complete(&r->c);
++	}
++
++	supp->ctx = NULL;
++	supp->req = NULL;
++
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_enqueue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_add_tail(&req->node, &supp->reqs);
++	mutex_unlock(&supp->mutex);
++}
++
++static void supp_dequeue_req(struct mbedtee_supp *supp,
++	struct mbedtee_supp_req *req)
++{
++	mutex_lock(&supp->mutex);
++	list_del(&req->node);
++	mutex_unlock(&supp->mutex);
++}
++
++/*
++ * receive the request from mbedtee,
++ * then push it to mbedtee_supp
++ */
++int mbedtee_supp_handler(struct mbedtee_clnt *clnt,
++	u32 func, void *data, size_t size)
++{
++	int ret = -1;
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL);
++
++	if (req == NULL)
++		return -ENOMEM;
++
++	init_completion(&req->c);
++	req->func = func;
++	req->data = data;
++	req->size = size;
++
++	supp_enqueue_req(supp, req);
++
++	/* wakeup the mbedtee_supp daemon to handle this request */
++	complete(&supp->reqs_c);
++
++	if (wait_for_completion_interruptible(&req->c)) {
++		req->ret = -ERESTARTSYS;
++		supp_dequeue_req(supp, req);
++	}
++
++	ret = req->ret;
++	kfree(req);
++	return ret;
++}
++
++static struct mbedtee_supp_req *supp_pop_req(struct mbedtee_supp *supp)
++{
++	struct mbedtee_supp_req *req;
++
++	mutex_lock(&supp->mutex);
++
++	/*
++	 * last request not finishs
++	 */
++	if (supp->req != NULL) {
++		req = ERR_PTR(-EINVAL);
++		goto out;
++	}
++
++	req = list_first_entry_or_null(&supp->reqs,
++			struct mbedtee_supp_req, node);
++
++	if (req) {
++		list_del(&req->node);
++		supp->req = req;
++	}
++
++out:
++	mutex_unlock(&supp->mutex);
++	return req;
++}
++
++/*
++ * receive request for mbedtee_supp
++ */
++int mbedtee_supp_recv(struct tee_context *ctx,
++	u32 *func, u32 *num_params, struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = NULL;
++	struct mbedtee_context_data *d = ctx->data;
++	struct tee_shm *shm = param->u.memref.shm;
++
++	if (*num_params != 1)
++		return -EINVAL;
++
++	if ((tee_param_is_memref(param) != true) ||
++		(param->u.memref.shm == NULL))
++		return -EINVAL;
++
++	d->is_supp_ctx = true;
++
++	tee_shm_put(shm);
++
++	while (true) {
++		req = supp_pop_req(supp);
++		if (IS_ERR(req))
++			return PTR_ERR(req);
++
++		if (req != NULL)
++			break;
++
++		if (wait_for_completion_interruptible(&supp->reqs_c))
++			return -ERESTARTSYS;
++	}
++
++	if (req->size > param->u.memref.size)
++		return -EOVERFLOW;
++
++	*func = req->func;
++	req->shm = shm;
++
++	memcpy(shm->kaddr, req->data, req->size);
++	param->u.memref.size = req->size;
++
++	return 0;
++}
++
++/*
++ * mbedtee_supp send result to mbedtee_supp_handler()
++ */
++int mbedtee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
++		    struct tee_param *param)
++{
++	struct tee_device *teedev = ctx->teedev;
++	struct mbedtee_clnt *clnt = tee_get_drvdata(teedev);
++	struct mbedtee_supp *supp = &clnt->supp;
++	struct mbedtee_supp_req *req = supp->req;
++
++	if (IS_ERR_OR_NULL(req))
++		return PTR_ERR(req);
++
++	if (req->size < param->u.memref.size)
++		ret = -EOVERFLOW;
++
++	req->ret = ret;
++	memcpy(req->data, req->shm->kaddr, param->u.memref.size);
++
++	mutex_lock(&supp->mutex);
++	supp->req = NULL;
++	mutex_unlock(&supp->mutex);
++
++	/* wakeup mbedtee_supp_handler() */
++	complete(&req->c);
++
++	return 0;
++}
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tee/tee_core.c linux-6.9.10/drivers/tee/tee_core.c
+--- linux-6.9.10-ori/drivers/tee/tee_core.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/tee/tee_core.c	2024-11-20 17:45:56.171779555 +0800
+@@ -578,8 +578,10 @@ static int tee_ioctl_invoke(struct tee_c
+ 			return -ENOMEM;
+ 		uparams = uarg->params;
+ 		rc = params_from_user(ctx, params, arg.num_params, uparams);
+-		if (rc)
++		if (rc) {
++			pr_emerg("rc %d\n", rc);
+ 			goto out;
++		}
+ 	}
+ 
+ 	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/drivers/tty/serial/amba-pl011.c linux-6.9.10/drivers/tty/serial/amba-pl011.c
+--- linux-6.9.10-ori/drivers/tty/serial/amba-pl011.c	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/drivers/tty/serial/amba-pl011.c	2024-11-20 17:11:08.716744791 +0800
+@@ -2575,6 +2575,51 @@ static int pl011_early_read(struct conso
+ #define pl011_early_read NULL
+ #endif
+ 
++static __init void __pl011_early_port_setup(struct uart_port *p)
++{
++	int brd_i = 0;
++	int brd_f = 0;
++	int baud = 115200, divisor = 16;
++
++	p->uartclk = 24000000;
++
++	/*
++	 * Disable all
++	 */
++	iowrite32(0, p->membase + UART011_CR);
++
++	/* mask/clear all interrupt */
++	iowrite32(0, p->membase + UART011_IMSC);
++	iowrite32(UART011_OEIC | UART011_BEIC | UART011_PEIC |
++				UART011_FEIC | UART011_RTIC | UART011_RXIC,
++			p->membase + UART011_ICR);
++
++	/* Baud rate divisor
++	 *	BAUDDIV = (FUARTCLK/ {16 * Baud rate})
++	 *  fractional part, m = integer((x * 64) + 0.5)
++	 */
++	brd_i = p->uartclk * 64 / (baud * divisor);
++	brd_f = brd_i & 0x3F;
++	brd_i >>= 6;
++	iowrite32(brd_i, p->membase + UART011_IBRD);
++	iowrite32(brd_f, p->membase + UART011_FBRD);
++
++	/*
++	 * 8-bit data, 1-bit stop, none-parity, with FIFO
++	 */
++	iowrite32(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN,
++				p->membase + UART011_LCRH);
++	iowrite32(UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++				p->membase + UART011_IFLS);
++
++	/*
++	 * Enable UART - TX only
++	 */
++	iowrite32(UART01x_CR_UARTEN | UART011_CR_TXE,
++				p->membase + UART011_CR);
++	iowrite32(UART011_TXIM, p->membase + UART011_IMSC);
++}
++
+ /*
+  * On non-ACPI systems, earlycon is enabled by specifying
+  * "earlycon=pl011,<address>" on the kernel command line.
+@@ -2593,6 +2638,8 @@ static int __init pl011_early_console_se
+ 	if (!device->port.membase)
+ 		return -ENODEV;
+ 
++	__pl011_early_port_setup(&device->port);
++
+ 	device->con->write = pl011_early_write;
+ 	device->con->read = pl011_early_read;
+ 
+diff -uprN '--exclude=.*' '--exclude=GNU*' linux-6.9.10-ori/include/uapi/linux/tee.h linux-6.9.10/include/uapi/linux/tee.h
+--- linux-6.9.10-ori/include/uapi/linux/tee.h	2024-07-18 19:22:56.000000000 +0800
++++ linux-6.9.10/include/uapi/linux/tee.h	2024-11-20 17:11:08.718744791 +0800
+@@ -57,6 +57,8 @@
+ #define TEE_IMPL_ID_OPTEE	1
+ #define TEE_IMPL_ID_AMDTEE	2
+ 
++#define TEE_IMPL_ID_MBEDTEE	8
++
+ /*
+  * OP-TEE specific capabilities
+  */
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/mbedtee-linux-dts/Config.in buildroot/tee/linux/mbedtee-linux-dts/Config.in
--- buildroot-ori/tee/linux/mbedtee-linux-dts/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/mbedtee-linux-dts/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_LINUX_DTS
+	bool "DTS for REE Linux which runs alongside MbedTEE"
+	depends on BR2_LINUX_KERNEL
+	help
+	  DTS for REE Linux which runs alongside MbedTEE
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/linux/mbedtee-linux-dts/mbedtee-linux-dts.mk buildroot/tee/linux/mbedtee-linux-dts/mbedtee-linux-dts.mk
--- buildroot-ori/tee/linux/mbedtee-linux-dts/mbedtee-linux-dts.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/linux/mbedtee-linux-dts/mbedtee-linux-dts.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,30 @@
+################################################################################
+#
+# DTS for Linux which runs alongside the MbedTEE
+#
+################################################################################
+
+MBEDTEE_LINUX_DTS_VERSION = main
+MBEDTEE_LINUX_DTS_SITE_METHOD = git
+MBEDTEE_LINUX_DTS_SITE = https://github.com/mbedtee/mbedtee-linux-dts.git
+MBEDTEE_LINUX_DTS_SOURCE = mbedtee-linux-dts-$(MBEDTEE_LINUX_DTS_VERSION).tar.gz
+MBEDTEE_LINUX_DTS_RELEASE_NAME = mbedtee-linux-dts-$(MBEDTEE_LINUX_DTS_VERSION).tar.gz
+
+MBEDTEE_LINUX_DTS_INSTALL_IMAGES = YES
+
+MBEDTEE_LINUX_DTS_DEPENDENCIES = host-dtc
+
+MBEDTEE_LINUX_DTS_PLATFORM = $(subst ",,$(BR2_PLATFORM_NAME))
+
+MBEDTEE_LINUX_DTS_MAKE_FLAGS = PLATFORM=$(MBEDTEE_LINUX_DTS_PLATFORM)
+MBEDTEE_LINUX_DTS_MAKE_FLAGS += DTC=$(HOST_DIR)/usr/bin/dtc
+
+define MBEDTEE_LINUX_DTS_BUILD_CMDS
+	$(MAKE) $(MBEDTEE_LINUX_DTS_MAKE_FLAGS) -C $(@D)
+endef
+
+define MBEDTEE_LINUX_DTS_INSTALL_IMAGES_CMDS
+	$(INSTALL) -D -m 0777 $(@D)/dtb/$(MBEDTEE_LINUX_DTS_PLATFORM).dtb $(BINARIES_DIR)/linux.dtb
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/Config.in buildroot/tee/mbedtee/Config.in
--- buildroot-ori/tee/mbedtee/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,28 @@
+config BR2_PACKAGE_MBEDTEE
+	bool "mbedtee packages"
+	help
+	  enable mbedtee system support
+
+if BR2_PACKAGE_MBEDTEE
+
+source "tee/mbedtee/mbedtee-os/Config.in"
+
+source "tee/mbedtee/mbedtee-common/Config.in"
+
+source "tee/mbedtee/mbedtee-supp/Config.in"
+
+source "tee/mbedtee/mbedtee-crypto/Config.in"
+
+source "tee/mbedtee/mbedtee-client-api/Config.in"
+
+source "tee/mbedtee/mbedtee-client-app/Config.in"
+
+source "tee/mbedtee/mbedtee-ta/Config.in"
+
+config BR2_PLATFORM_NAME
+	string "mbedtee platform"
+	
+config BR2_PLATFORM_CFG
+	string "mbedtee defconfig"
+
+endif
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-api/Config.in buildroot/tee/mbedtee/mbedtee-client-api/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-client-api/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-api/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_CLIENT_API
+	bool "mbedtee client API"
+	default y
+   	help
+		MbedTEE - GlobalPlatform Client API
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-api/mbedtee-client-api.mk buildroot/tee/mbedtee/mbedtee-client-api/mbedtee-client-api.mk
--- buildroot-ori/tee/mbedtee/mbedtee-client-api/mbedtee-client-api.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-api/mbedtee-client-api.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,49 @@
+# =========================================================
+# GlobalPlatform Client API @ mbedtee
+# =========================================================
+
+MBEDTEE_CLIENT_API_VERSION := main
+MBEDTEE_CLIENT_API_SITE_METHOD = git
+MBEDTEE_CLIENT_API_SITE = https://github.com/mbedtee/mbedtee-client-api.git
+MBEDTEE_CLIENT_API_SOURCE = mbedtee-client-api-$(MBEDTEE_CLIENT_API_VERSION).tar.gz
+MBEDTEE_CLIENT_API_RELEASE_NAME = mbedtee-client-api-$(MBEDTEE_CLIENT_API_VERSION).tar.gz
+
+MBEDTEE_CLIENT_API_INSTALL_TARGET = YES
+MBEDTEE_CLIENT_API_INSTALL_STAGING = YES
+
+MBEDTEE_CLIENT_API_DEPENDENCIES = toolchain mbedtee-common
+
+MBEDTEE_CLIENT_LIB_STAGING_DIR = $(STAGING_DIR)/usr/lib
+
+MBEDTEE_CLIENT_API_TARGET = libteec_api.so
+
+ifeq ($(ARCH),arm)
+MBEDTEE_CLIENT_API_ARCH_FLAGS = -fPIC
+else ifeq ($(ARCH),aarch64)
+MBEDTEE_CLIENT_API_ARCH_FLAGS = -fPIC
+else ifeq ($(ARCH),mipsel)
+MBEDTEE_CLIENT_API_ARCH_FLAGS = "-EL -fPIC -mabicalls"
+else ifneq ($(findstring $(ARCH), riscv32 riscv64),)
+MBEDTEE_CLIENT_API_ARCH_FLAGS = -fPIC
+endif
+
+MBEDTEE_CLIENT_API_MAKE_FLAGS = CROSS_COMPILE=$(TARGET_CROSS)
+MBEDTEE_CLIENT_API_MAKE_FLAGS += ARCH_FLAGS=$(MBEDTEE_CLIENT_API_ARCH_FLAGS)
+MBEDTEE_CLIENT_API_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+MBEDTEE_CLIENT_API_MAKE_FLAGS += TARGET_NAME=$(MBEDTEE_CLIENT_API_TARGET)
+
+define MBEDTEE_CLIENT_API_BUILD_CMDS
+	make $(MBEDTEE_CLIENT_API_MAKE_FLAGS) -C $(@D)
+endef
+
+define MBEDTEE_CLIENT_API_INSTALL_TARGET_CMDS
+	$(INSTALL) -D -m 0777 $(@D)/$(MBEDTEE_CLIENT_API_TARGET) $(TARGET_DIR)/lib
+endef
+
+define MBEDTEE_CLIENT_API_INSTALL_STAGING_CMDS
+	@mkdir -p $(MBEDTEE_CLIENT_LIB_STAGING_DIR)
+	@cp -raf $(@D)/include/public/* $(MBEDTEE_COMMON_INC_STAGING_DIR)
+	$(INSTALL) -D -m 0777 $(@D)/$(MBEDTEE_CLIENT_API_TARGET) $(MBEDTEE_CLIENT_LIB_STAGING_DIR)
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-app/Config.in buildroot/tee/mbedtee/mbedtee-client-app/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-client-app/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-app/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,11 @@
+config BR2_PACKAGE_MBEDTEE_CLIENT_APP
+	bool "mbedtee client APP"
+   	help
+		Client Applications @ REE
+
+if BR2_PACKAGE_MBEDTEE_CLIENT_APP
+
+source "tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/Config.in"
+source "tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/Config.in"
+
+endif
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-client-app.mk buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-client-app.mk
--- buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-client-app.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-client-app.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1 @@
+include $(sort $(wildcard tee/mbedtee/mbedtee-client-app/*/*.mk))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/Config.in buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_GLOBALPLATFORM_CLIENT
+	bool "mbedtee GlobalPlatform client"
+	default n
+   	help
+		GlobalPlatform TestSuite @ REE
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/mbedtee-globalplatform-client.mk buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/mbedtee-globalplatform-client.mk
--- buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/mbedtee-globalplatform-client.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-globalplatform-client/mbedtee-globalplatform-client.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,30 @@
+# =========================================================
+# GlobalPlatform TestSuite @ REE
+# =========================================================
+
+MBEDTEE_GLOBALPLATFORM_CLIENT_VERSION := main
+MBEDTEE_GLOBALPLATFORM_CLIENT_SITE_METHOD = git
+MBEDTEE_GLOBALPLATFORM_CLIENT_SITE = https://github.com/mbedtee/mbedtee-globalplatform-client.git
+MBEDTEE_GLOBALPLATFORM_CLIENT_SOURCE = mbedtee-globalplatform-client-$(MBEDTEE_GLOBALPLATFORM_CLIENT_VERSION).tar.gz
+MBEDTEE_GLOBALPLATFORM_CLIENT_RELEASE_NAME = mbedtee-globalplatform-client-$(MBEDTEE_GLOBALPLATFORM_CLIENT_VERSION).tar.gz
+
+MBEDTEE_GLOBALPLATFORM_CLIENT_INSTALL_TARGET = YES
+
+MBEDTEE_GLOBALPLATFORM_CLIENT_DEPENDENCIES = toolchain mbedtee-os mbedtee-client-api
+
+MBEDTEE_GLOBALPLATFORM_CLIENT_TARGET_DIR = $(TARGET_DIR)/bin
+
+MBEDTEE_GLOBALPLATFORM_CLIENT_MAKE_FLAGS = CROSS_COMPILE=$(TARGET_CROSS) ARCH=$(ARCH)
+MBEDTEE_GLOBALPLATFORM_CLIENT_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+MBEDTEE_GLOBALPLATFORM_CLIENT_MAKE_FLAGS += GP_TEEC_LIB=$(MBEDTEE_CLIENT_LIB_STAGING_DIR)/libteec_api.so
+
+define MBEDTEE_GLOBALPLATFORM_CLIENT_BUILD_CMDS
+	make $(MBEDTEE_GLOBALPLATFORM_CLIENT_MAKE_FLAGS) -C $(@D)
+endef
+
+define MBEDTEE_GLOBALPLATFORM_CLIENT_INSTALL_TARGET_CMDS
+	@mkdir -p $(MBEDTEE_GLOBALPLATFORM_CLIENT_TARGET_DIR)
+	$(INSTALL) -D -m 0777 $(@D)/bin/* $(MBEDTEE_GLOBALPLATFORM_CLIENT_TARGET_DIR)
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/Config.in buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_HELLOWORLD_CLIENT
+	bool "mbedtee HelloWorld client"
+	default n
+   	help
+		HelloWorld Client APP @ REE
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/mbedtee-helloworld-client.mk buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/mbedtee-helloworld-client.mk
--- buildroot-ori/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/mbedtee-helloworld-client.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-client-app/mbedtee-helloworld-client/mbedtee-helloworld-client.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,30 @@
+# =========================================================
+# HelloWorld Client APP @ REE
+# =========================================================
+
+MBEDTEE_HELLOWORLD_CLIENT_VERSION := main
+MBEDTEE_HELLOWORLD_CLIENT_SITE_METHOD = git
+MBEDTEE_HELLOWORLD_CLIENT_SITE = https://github.com/mbedtee/mbedtee-helloworld-client.git
+MBEDTEE_HELLOWORLD_CLIENT_SOURCE = mbedtee-helloworld-client-$(MBEDTEE_HELLOWORLD_CLIENT_VERSION).tar.gz
+MBEDTEE_HELLOWORLD_CLIENT_RELEASE_NAME = mbedtee-helloworld-client-$(MBEDTEE_HELLOWORLD_CLIENT_VERSION).tar.gz
+
+MBEDTEE_HELLOWORLD_CLIENT_INSTALL_TARGET = YES
+
+MBEDTEE_HELLOWORLD_CLIENT_DEPENDENCIES = toolchain mbedtee-os mbedtee-client-api
+
+MBEDTEE_HELLOWORLD_CLIENT_TARGET_DIR = $(TARGET_DIR)/bin
+
+MBEDTEE_HELLOWORLD_CLIENT_MAKE_FLAGS = CROSS_COMPILE=$(TARGET_CROSS) ARCH=$(ARCH)
+MBEDTEE_HELLOWORLD_CLIENT_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+MBEDTEE_HELLOWORLD_CLIENT_MAKE_FLAGS += GP_TEEC_LIB=$(MBEDTEE_CLIENT_LIB_STAGING_DIR)/libteec_api.so
+
+define MBEDTEE_HELLOWORLD_CLIENT_BUILD_CMDS
+	make $(MBEDTEE_HELLOWORLD_CLIENT_MAKE_FLAGS) -C $(@D)
+endef
+
+define MBEDTEE_HELLOWORLD_CLIENT_INSTALL_TARGET_CMDS
+	@mkdir -p $(MBEDTEE_HELLOWORLD_CLIENT_TARGET_DIR)
+	$(INSTALL) -D -m 0777 $(@D)/bin/* $(MBEDTEE_HELLOWORLD_CLIENT_TARGET_DIR)
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-common/Config.in buildroot/tee/mbedtee/mbedtee-common/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-common/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-common/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_COMMON
+	bool "mbedtee common"
+	default y
+   	help
+		MbedTEE - Common Files for REE and TEE
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-common/mbedtee-common.mk buildroot/tee/mbedtee/mbedtee-common/mbedtee-common.mk
--- buildroot-ori/tee/mbedtee/mbedtee-common/mbedtee-common.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-common/mbedtee-common.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,20 @@
+# =========================================================
+# MbedTEE Common Files for REE, TEE and TA
+# =========================================================
+
+MBEDTEE_COMMON_VERSION := main
+MBEDTEE_COMMON_SITE_METHOD = git
+MBEDTEE_COMMON_SITE = https://github.com/mbedtee/mbedtee-common.git
+MBEDTEE_COMMON_SOURCE = mbedtee-common-$(MBEDTEE_COMMON_VERSION).tar.gz
+MBEDTEE_COMMON_RELEASE_NAME = mbedtee-common-$(MBEDTEE_COMMON_VERSION).tar.gz
+
+MBEDTEE_COMMON_INSTALL_STAGING = YES
+
+MBEDTEE_COMMON_INC_STAGING_DIR = $(STAGING_DIR)/usr/include/mbedtee
+
+define MBEDTEE_COMMON_INSTALL_STAGING_CMDS
+	@mkdir -p $(MBEDTEE_COMMON_INC_STAGING_DIR)
+	@cp -raf $(@D)/* $(MBEDTEE_COMMON_INC_STAGING_DIR)
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-crypto/Config.in buildroot/tee/mbedtee/mbedtee-crypto/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-crypto/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-crypto/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_CRYPTO
+	bool "mbedtee cryptotool"
+	default n
+   	help
+		mbedtee - CryptoTool for crypt/signing TA
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-crypto/mbedtee-crypto.mk buildroot/tee/mbedtee/mbedtee-crypto/mbedtee-crypto.mk
--- buildroot-ori/tee/mbedtee/mbedtee-crypto/mbedtee-crypto.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-crypto/mbedtee-crypto.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,30 @@
+# =========================================================
+# MBEDTEE CRYPTO
+# =========================================================
+
+MBEDTEE_CRYPTO_VERSION := main
+MBEDTEE_CRYPTO_SITE_METHOD = git
+MBEDTEE_CRYPTO_SITE = https://github.com/mbedtee/mbedtee-crypto.git
+MBEDTEE_CRYPTO_SOURCE = mbedtee-crypto-$(MBEDTEE_CRYPTO_VERSION).tar.gz
+MBEDTEE_CRYPTO_RELEASE_NAME = mbedtee-crypto-$(MBEDTEE_CRYPTO_VERSION).tar.gz
+
+MBEDTEE_CRYPTO_TARGET_DIR = $(HOST_DIR)/usr/bin
+
+MBEDTEE_CRYPTO_TOOL = $(MBEDTEE_CRYPTO_TARGET_DIR)/cryptoclient
+
+MBEDTEE_CRYPTO_SERVER = $(@D)/server/cryptoserver
+
+define MBEDTEE_CRYPTO_BUILD_CMDS
+	make -C $(@D)/client
+	make -C $(@D)/server
+endef
+
+define MBEDTEE_CRYPTO_INSTALL_TARGET_CMDS
+	$(shell if [ ! -z `pidof cryptoserver` ]; then \
+		pidof cryptoserver | xargs kill -9; fi; \
+		cd $(@D)/server; $(MBEDTEE_CRYPTO_SERVER))
+	$(INSTALL) -D -m 0777 $(@D)/client/cryptoclient $(MBEDTEE_CRYPTO_TARGET_DIR)
+	$(shell cd $(@D)/server; $(MBEDTEE_CRYPTO_SERVER))
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee.mk buildroot/tee/mbedtee/mbedtee.mk
--- buildroot-ori/tee/mbedtee/mbedtee.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1 @@
+include $(sort $(wildcard tee/mbedtee/*/*.mk))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-os/Config.in buildroot/tee/mbedtee/mbedtee-os/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-os/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-os/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,9 @@
+config BR2_PACKAGE_MBEDTEE_OS
+	bool "mbedtee OS"
+	select BR2_TOOLCHAIN_MBEDTEE_ARM if BR2_ARM_CPU_ARMV7A
+	select BR2_TOOLCHAIN_MBEDTEE_AARCH64 if BR2_ARM_CPU_ARMV8A
+	select BR2_TOOLCHAIN_MBEDTEE_RISCV32 if BR2_RISCV_32
+	select BR2_TOOLCHAIN_MBEDTEE_RISCV64 if BR2_RISCV_64
+	select BR2_TOOLCHAIN_MBEDTEE_MIPS if BR2_MIPS_CPU_MIPS32R2
+	help
+	  with mbedtee system support
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-os/mbedtee-os.mk buildroot/tee/mbedtee/mbedtee-os/mbedtee-os.mk
--- buildroot-ori/tee/mbedtee/mbedtee-os/mbedtee-os.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-os/mbedtee-os.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,103 @@
+# =========================================================
+# MBEDTEE OS
+# =========================================================
+
+MBEDTEE_OS_VERSION = main
+MBEDTEE_OS_SITE_METHOD = git
+MBEDTEE_OS_SITE = https://github.com/mbedtee/mbedtee-os.git
+MBEDTEE_OS_SOURCE = mbedtee-os-$(MBEDTEE_OS_VERSION).tar.gz
+MBEDTEE_OS_RELEASE_NAME = mbedtee-os-$(MBEDTEE_OS_VERSION).tar.gz
+
+MBEDTEE_OS_INSTALL_IMAGES = YES
+MBEDTEE_OS_ALWAYS_INSTALL_IMAGES = YES
+
+MBEDTEE_OS_DEPENDENCIES = host-dtc host-dosfstools host-mtools host-bison host-flex
+
+MBEDTEE_OS_DEPENDENCIES += mbedtee-common
+
+MBEDTEE_OS_DEFAULT_CONFIG = $(BR2_PLATFORM_CFG)
+
+ifeq ($(ARCH),arm)
+MBEDTEE_OS_DEPENDENCIES += toolchain-mbedtee-arm
+MBEDTEE_OS_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_ARM_CROSS)
+else ifeq ($(ARCH),aarch64)
+MBEDTEE_OS_DEPENDENCIES += toolchain-mbedtee-aarch64
+MBEDTEE_OS_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_AARCH64_CROSS)
+else ifeq ($(ARCH),mipsel)
+MBEDTEE_OS_DEPENDENCIES += toolchain-mbedtee-mips
+MBEDTEE_OS_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_MIPS_CROSS)
+else ifeq ($(ARCH),riscv32)
+MBEDTEE_OS_DEPENDENCIES += toolchain-mbedtee-riscv32
+MBEDTEE_OS_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_RISCV32_CROSS)
+else ifeq ($(ARCH),riscv64)
+MBEDTEE_OS_DEPENDENCIES += toolchain-mbedtee-riscv64
+MBEDTEE_OS_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_RISCV64_CROSS)
+endif
+
+BR_NO_CHECK_HASH_FOR += $(MBEDTEE_OS_SOURCE)
+
+MBEDTEE_OS_MAKE_FLAGS += BUILD_VERSION=$(MBEDTEE_OS_VERSION) VERBOSE=$(V)
+
+MBEDTEE_OS_BINARY_NAME = mbedtee.bin
+MBEDTEE_OS_ELF_NAME = mbedtee.elf
+MBEDTEE_OS_RELEASE_NAME = mbedtee.ubo
+
+MBEDTEE_LIBC_STAGING_DIR = $(STAGING_DIR)/usr/lib/mbedtee
+
+MBEDTEE_TARAMFS_SIZE = 0x200000
+MBEDTEE_TARAMFS = $(TARGET_DIR)/data/mbedtee/reefs/ta.ramfs
+MBEDTEE_TARAMFS_MKFS = $(HOST_DIR)/sbin/mkfs.vfat
+MBEDTEE_TARAMFS_GENERATE = `if [ ! -e $(MBEDTEE_TARAMFS) ]; then \
+		mkdir -p $(shell dirname $(MBEDTEE_TARAMFS)); \
+		dd if=/dev/zero of=$(MBEDTEE_TARAMFS) bs=$(shell printf %d $(MBEDTEE_TARAMFS_SIZE)) count=1; \
+		$(MBEDTEE_TARAMFS_MKFS) -F 12 $(MBEDTEE_TARAMFS) 2> /dev/null; \
+		$(HOST_DIR)/bin/mcopy -pQ -i $(MBEDTEE_TARAMFS) -os $(@D)/bin/skeleton/* ::; fi`
+
+MBEDTEE_OS_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+MBEDTEE_OS_MAKE_FLAGS += DTC=$(HOST_DIR)/bin/dtc MCOPY=$(HOST_DIR)/bin/mcopy
+MBEDTEE_OS_MAKE_FLAGS += MKFS_VFAT=$(MBEDTEE_TARAMFS_MKFS)
+
+define MBEDTEE_OS_GENERATE_LIBRARY
+	$(BR2_MAKE) $(MBEDTEE_OS_MAKE_FLAGS) -C $(@D)
+endef
+
+define MBEDTEE_OS_INSTALL_STAGING_CMDS
+	@mkdir -p $(MBEDTEE_COMMON_INC_STAGING_DIR)/tee
+	@cp -raf $(@D)/include/*.h $(MBEDTEE_COMMON_INC_STAGING_DIR)/tee
+endef
+
+define MBEDTEE_OS_BUILD_CMDS
+	@rm -f $(MBEDTEE_OS_DIR)/.stamp_rsynced
+	$(MBEDTEE_OS_INSTALL_STAGING_CMDS)
+	$(MBEDTEE_OS_GENERATE_LIBRARY)
+endef
+
+define MBEDTEE_OS_INSTALL_BINARY_CMDS
+	$(INSTALL) -D -m 0777 $(@D)/bin/${MBEDTEE_OS_BINARY_NAME} $(BINARIES_DIR)
+	$(INSTALL) -D -m 0777 $(@D)/bin/${MBEDTEE_OS_ELF_NAME} $(BINARIES_DIR)
+endef
+
+define MBEDTEE_OS_INSTALL_IMAGES_CMDS
+	@cp -rf $(@D)/lib/mbedtls/include/* $(MBEDTEE_COMMON_INC_STAGING_DIR)/tee/
+	$(MBEDTEE_OS_INSTALL_BINARY_CMDS)
+	@if [ -e $(@D)/bin/libc.so ]; then \
+		mkdir -p $(MBEDTEE_LIBC_STAGING_DIR); \
+		$(INSTALL) -D -m 0777 $(@D)/bin/libc.so $(MBEDTEE_LIBC_STAGING_DIR); \
+	fi
+	@echo ${MBEDTEE_TARAMFS_GENERATE} > /dev/null
+endef
+
+define MBEDTEE_OS_CONFIGURE_CMDS
+	@$(call MESSAGE,"$(MBEDTEE_OS_DEFAULT_CONFIG)")
+	@$(BR2_MAKE) $(MBEDTEE_OS_MAKE_FLAGS) -C $(@D) $(MBEDTEE_OS_DEFAULT_CONFIG)
+endef
+
+mbedtee-os-menuconfig: mbedtee-os-configure
+	$(BR2_MAKE) $(MBEDTEE_OS_MAKE_FLAGS) -C $(MBEDTEE_OS_DIR) menuconfig
+	@rm -f $(MBEDTEE_OS_DIR)/.stamp_{rsynced,built,target_installed,images_installed}
+
+define MBEDTEE_OS_HELP_CMDS
+	@echo '  mbedtee-os-menuconfig  - Run mbedtee OS menuconfig'
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-supp/Config.in buildroot/tee/mbedtee/mbedtee-supp/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-supp/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-supp/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,6 @@
+config BR2_PACKAGE_MBEDTEE_SUPP
+	bool "mbedtee supplicant"
+	default y
+   	help
+		build a linux daemon to handle the mbedtee requests
+		(handles the requests in Linux userspace, e.g. REEFS) 
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-supp/mbedtee-supp.mk buildroot/tee/mbedtee/mbedtee-supp/mbedtee-supp.mk
--- buildroot-ori/tee/mbedtee/mbedtee-supp/mbedtee-supp.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-supp/mbedtee-supp.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,28 @@
+# ===========================================================
+# linux daemon for handling the mbedtee requests, e.g. REEFS
+# ===========================================================
+
+MBEDTEE_SUPP_VERSION := main
+MBEDTEE_SUPP_SITE_METHOD = git
+MBEDTEE_SUPP_SITE = https://github.com/mbedtee/mbedtee-supp.git
+MBEDTEE_SUPP_SOURCE = mbedtee-supp-$(MBEDTEE_SUPP_VERSION).tar.gz
+MBEDTEE_SUPP_RELEASE_NAME = mbedtee-supp-$(MBEDTEE_SUPP_VERSION).tar.gz
+
+MBEDTEE_SUPP_INSTALL_TARGET = YES
+MBEDTEE_SUPP_INSTALL_STAGING = YES
+
+MBEDTEE_SUPP_DEPENDENCIES = toolchain mbedtee-common
+
+MBEDTEE_SUPP_MAKE_FLAGS = CROSS_COMPILE=$(TARGET_CROSS)
+MBEDTEE_SUPP_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+
+define MBEDTEE_SUPP_BUILD_CMDS
+	make $(MBEDTEE_SUPP_MAKE_FLAGS) -C $(@D)
+endef
+
+define MBEDTEE_SUPP_INSTALL_TARGET_CMDS
+	$(INSTALL) -D -m 0777 $(@D)/mbedtee_supp $(TARGET_DIR)/bin
+	$(INSTALL) -D -m 0777 $(@D)/S44supp $(TARGET_DIR)/etc/init.d
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-ta/Config.in buildroot/tee/mbedtee/mbedtee-ta/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-ta/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-ta/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,12 @@
+config BR2_PACKAGE_MBEDTEE_TA
+	bool "mbedtee TA"
+	select BR2_PACKAGE_MBEDTEE_CRYPTO
+   	help
+		MbedTEE - Trust Applications
+
+if BR2_PACKAGE_MBEDTEE_TA
+
+source "tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/Config.in"
+source "tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/Config.in"
+
+endif
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/Config.in buildroot/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_GLOBALPLATFORM_TA
+	bool "mbedtee GlobalPlatform TA"
+	default n
+   	help
+		TA - GlobalPlatform TEE test suite
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/mbedtee-globalplatform-ta.mk buildroot/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/mbedtee-globalplatform-ta.mk
--- buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/mbedtee-globalplatform-ta.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-ta/mbedtee-globalplatform-ta/mbedtee-globalplatform-ta.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,73 @@
+# =========================================================
+# MBEDTEE GlobalPlatform TestSuite TAs
+# =========================================================
+
+MBEDTEE_GLOBALPLATFORM_TA_VERSION := main
+MBEDTEE_GLOBALPLATFORM_TA_SITE_METHOD = git
+MBEDTEE_GLOBALPLATFORM_TA_SITE = https://github.com/mbedtee/mbedtee-globalplatform-ta.git
+MBEDTEE_GLOBALPLATFORM_TA_SOURCE = mbedtee-globalplatform-ta-$(MBEDTEE_GLOBALPLATFORM_TA_VERSION).tar.gz
+MBEDTEE_GLOBALPLATFORM_TA_RELEASE_NAME = mbedtee-globalplatform-ta-$(MBEDTEE_GLOBALPLATFORM_TA_VERSION).tar.gz
+
+MBEDTEE_GLOBALPLATFORM_TA_INSTALL_TARGET = YES
+
+MBEDTEE_GLOBALPLATFORM_TA_DEPENDENCIES = mbedtee-crypto mbedtee-os
+
+ifeq ($(ARCH),arm)
+MBEDTEE_GLOBALPLATFORM_TA_DEPENDENCIES += toolchain-mbedtee-arm
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_ARM_CROSS)
+MBEDTEE_GLOBALPLATFORM_TA_ARCH_CFLAGS = "-fPIE -msoft-float"
+else ifeq ($(ARCH),aarch64)
+MBEDTEE_GLOBALPLATFORM_TA_DEPENDENCIES += toolchain-mbedtee-aarch64
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_AARCH64_CROSS)
+MBEDTEE_GLOBALPLATFORM_TA_ARCH_CFLAGS = "-fPIE"
+else ifeq ($(ARCH),mipsel)
+MBEDTEE_GLOBALPLATFORM_TA_DEPENDENCIES += toolchain-mbedtee-mips
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_MIPS_CROSS)
+MBEDTEE_GLOBALPLATFORM_TA_ARCH_CFLAGS = "-EL -fPIE -mabicalls -msoft-float -G 0 -mno-gpopt"
+else ifeq ($(ARCH),riscv32)
+MBEDTEE_GLOBALPLATFORM_TA_DEPENDENCIES += toolchain-mbedtee-riscv32
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_RISCV32_CROSS)
+MBEDTEE_GLOBALPLATFORM_TA_ARCH_CFLAGS = "-fPIE -mabi=ilp32d -march=rv32imafd -mstrict-align"
+else ifeq ($(ARCH),riscv64)
+MBEDTEE_GLOBALPLATFORM_TA_DEPENDENCIES += toolchain-mbedtee-riscv64
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_RISCV64_CROSS)
+MBEDTEE_GLOBALPLATFORM_TA_ARCH_CFLAGS = "-fPIE -mabi=lp64d -march=rv64imafd -mstrict-align"
+endif
+
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS += MBEDTEE_LIBC=$(MBEDTEE_LIBC_STAGING_DIR)
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS += ARCH_CFLAGS=$(MBEDTEE_GLOBALPLATFORM_TA_ARCH_CFLAGS)
+
+MBEDTEE_GLOBALPLATFORM_TA_SIGN_OBJ = $(@D)/signed
+
+MBEDTEE_GLOBALPLATFORM_TAS = TTA_DS TTA_TCF TTA_TCF_ICA TTA_TCF_ICA2 \
+				TTA_answerSuccessTo_OpenSession_Invoke TTA_Arithmetical \
+				TTA_answerErrorTo_Invoke TTA_answerErrorTo_OpenSession \
+				TTA_check_OpenSession_with_4_parameters TTA_Crypto \
+				TTA_TCF_MultipleInstanceTA TTA_TCF_PanicAtCloseSession  \
+				TTA_testingClientAPI_Parameters_Invoke TTA_testingClientAPI \
+				TTA_testingClientAPI_Parameters_OpenSession TTA_Time \
+				TTA_TCF_PanicAtCreation TTA_TCF_SingleInstanceTA
+
+MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS += TAS="$(MBEDTEE_GLOBALPLATFORM_TAS)"
+
+define MBEDTEE_GLOBALPLATFORM_TA_CRYPTO_CMDS
+        @mkdir -p $(MBEDTEE_GLOBALPLATFORM_TA_SIGN_OBJ)
+        for TA in $(MBEDTEE_GLOBALPLATFORM_TAS); do \
+		$(MBEDTEE_CRYPTO_TOOL) --type mbedtee-ta --platform generic \
+			--config-in $(@D)/$$TA.config --object-in $(@D)/$$TA \
+	   		--object-out $(MBEDTEE_GLOBALPLATFORM_TA_SIGN_OBJ)/$$TA.o \
+			--certificate-out $(MBEDTEE_GLOBALPLATFORM_TA_SIGN_OBJ)/$$TA.certi; \
+        done
+endef
+
+define MBEDTEE_GLOBALPLATFORM_TA_BUILD_CMDS
+	make $(MBEDTEE_GLOBALPLATFORM_TA_MAKE_FLAGS) -C $(@D) all
+	$(MBEDTEE_GLOBALPLATFORM_TA_CRYPTO_CMDS)
+endef
+
+define MBEDTEE_GLOBALPLATFORM_TA_INSTALL_TARGET_CMDS
+	$(HOST_DIR)/bin/mcopy -pQ -i $(MBEDTEE_TARAMFS) -os $(MBEDTEE_GLOBALPLATFORM_TA_SIGN_OBJ)/* ::
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/Config.in buildroot/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/Config.in
--- buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/Config.in	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_MBEDTEE_HELLOWORLD_TA
+	bool "mbedtee HelloWorld TA"
+	default n
+   	help
+		TA - Hello World
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/mbedtee-helloworld-ta.mk buildroot/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/mbedtee-helloworld-ta.mk
--- buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/mbedtee-helloworld-ta.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-ta/mbedtee-helloworld-ta/mbedtee-helloworld-ta.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1,63 @@
+# =========================================================
+# MBEDTEE HelloWorld TA
+# =========================================================
+
+MBEDTEE_HELLOWORLD_TA_VERSION := main
+MBEDTEE_HELLOWORLD_TA_SITE_METHOD = git
+MBEDTEE_HELLOWORLD_TA_SITE = https://github.com/mbedtee/mbedtee-helloworld-ta.git
+MBEDTEE_HELLOWORLD_TA_SOURCE = mbedtee-helloworld-ta-$(MBEDTEE_HELLOWORLD_TA_VERSION).tar.gz
+MBEDTEE_HELLOWORLD_TA_RELEASE_NAME = mbedtee-helloworld-ta-$(MBEDTEE_HELLOWORLD_TA_VERSION).tar.gz
+
+MBEDTEE_HELLOWORLD_TA_INSTALL_TARGET = YES
+
+MBEDTEE_HELLOWORLD_TA_DEPENDENCIES = mbedtee-crypto mbedtee-os
+
+ifeq ($(ARCH),arm)
+MBEDTEE_HELLOWORLD_TA_DEPENDENCIES += toolchain-mbedtee-arm
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_ARM_CROSS)
+MBEDTEE_HELLOWORLD_TA_ARCH_CFLAGS = "-fPIE -msoft-float"
+else ifeq ($(ARCH),aarch64)
+MBEDTEE_HELLOWORLD_TA_DEPENDENCIES += toolchain-mbedtee-aarch64
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_AARCH64_CROSS)
+MBEDTEE_HELLOWORLD_TA_ARCH_CFLAGS = "-fPIE"
+else ifeq ($(ARCH),mipsel)
+MBEDTEE_HELLOWORLD_TA_DEPENDENCIES += toolchain-mbedtee-mips
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_MIPS_CROSS)
+MBEDTEE_HELLOWORLD_TA_ARCH_CFLAGS = "-EL -fPIE -mabicalls -msoft-float -G 0 -mno-gpopt"
+else ifeq ($(ARCH),riscv32)
+MBEDTEE_HELLOWORLD_TA_DEPENDENCIES += toolchain-mbedtee-riscv32
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_RISCV32_CROSS)
+MBEDTEE_HELLOWORLD_TA_ARCH_CFLAGS = "-fPIE -mabi=ilp32d -march=rv32imafd -mstrict-align"
+else ifeq ($(ARCH),riscv64)
+MBEDTEE_HELLOWORLD_TA_DEPENDENCIES += toolchain-mbedtee-riscv64
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS = CROSS_COMPILE=$(TOOLCHAIN_MBEDTEE_RISCV64_CROSS)
+MBEDTEE_HELLOWORLD_TA_ARCH_CFLAGS = "-fPIE -mabi=lp64d -march=rv64imafd -mstrict-align"
+endif
+
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS += MBEDTEE_INC=$(MBEDTEE_COMMON_INC_STAGING_DIR)
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS += MBEDTEE_LIBC=$(MBEDTEE_LIBC_STAGING_DIR)
+MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS += ARCH_CFLAGS=$(MBEDTEE_HELLOWORLD_TA_ARCH_CFLAGS)
+
+MBEDTEE_HELLOWORLD_TA_NAME = mbedtee-helloworld-ta
+
+MBEDTEE_HELLOWORLD_TA_SIGN_OBJ = $(@D)/signed
+
+define MBEDTEE_HELLOWORLD_TA_CRYPTO_CMDS
+	@mkdir -p $(MBEDTEE_HELLOWORLD_TA_SIGN_OBJ)
+	$(MBEDTEE_CRYPTO_TOOL) --type mbedtee-ta --platform generic \
+					--config-in $(@D)/$(MBEDTEE_HELLOWORLD_TA_NAME).config \
+	        --object-in $(@D)/$(MBEDTEE_HELLOWORLD_TA_NAME) \
+	        --object-out $(MBEDTEE_HELLOWORLD_TA_SIGN_OBJ)/$(MBEDTEE_HELLOWORLD_TA_NAME).o \
+	        --certificate-out $(MBEDTEE_HELLOWORLD_TA_SIGN_OBJ)/$(MBEDTEE_HELLOWORLD_TA_NAME).certi
+endef
+
+define MBEDTEE_HELLOWORLD_TA_BUILD_CMDS
+	make $(MBEDTEE_HELLOWORLD_TA_MAKE_FLAGS) -C $(@D)
+	$(MBEDTEE_HELLOWORLD_TA_CRYPTO_CMDS)
+endef
+
+define MBEDTEE_HELLOWORLD_TA_INSTALL_TARGET_CMDS
+	$(HOST_DIR)/bin/mcopy -pQ -i $(MBEDTEE_TARAMFS) -so $(MBEDTEE_HELLOWORLD_TA_SIGN_OBJ)/* ::
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-ta.mk buildroot/tee/mbedtee/mbedtee-ta/mbedtee-ta.mk
--- buildroot-ori/tee/mbedtee/mbedtee-ta/mbedtee-ta.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/tee/mbedtee/mbedtee-ta/mbedtee-ta.mk	2020-10-01 00:00:00.000000000 +0800
@@ -0,0 +1 @@
+include $(sort $(wildcard tee/mbedtee/mbedtee-ta/*/*.mk))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/Config.in buildroot/toolchain/Config.in
--- buildroot-ori/toolchain/Config.in	2025-10-08 11:12:38.799326281 +0800
+++ buildroot/toolchain/Config.in	2025-10-07 12:05:15.455401476 +0800
@@ -60,6 +60,11 @@ endchoice
 
 source "toolchain/toolchain-buildroot/Config.in"
 source "toolchain/toolchain-external/Config.in"
+source "toolchain/toolchain-mbedtee-arm/Config.in"
+source "toolchain/toolchain-mbedtee-aarch64/Config.in"
+source "toolchain/toolchain-mbedtee-riscv32/Config.in"
+source "toolchain/toolchain-mbedtee-riscv64/Config.in"
+source "toolchain/toolchain-mbedtee-mips/Config.in"
 
 # Generic toolchain options
 
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-aarch64/Config.in buildroot/toolchain/toolchain-mbedtee-aarch64/Config.in
--- buildroot-ori/toolchain/toolchain-mbedtee-aarch64/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-aarch64/Config.in	2025-09-15 15:54:07.239753781 +0800
@@ -0,0 +1,7 @@
+config BR2_TOOLCHAIN_MBEDTEE_AARCH64
+	bool "mbedtee toolchain"
+	depends on BR2_aarch64
+	depends on BR2_ARM_CPU_ARMV8A
+	help
+	  armv8-a cross-toolchain with GCC
+
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-aarch64/--toolchain-mbedtee-aarch64.hash buildroot/toolchain/toolchain-mbedtee-aarch64/--toolchain-mbedtee-aarch64.hash
--- buildroot-ori/toolchain/toolchain-mbedtee-aarch64/--toolchain-mbedtee-aarch64.hash	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-aarch64/--toolchain-mbedtee-aarch64.hash	2025-09-15 15:54:07.239753781 +0800
@@ -0,0 +1,2 @@
+4# Locally calculated
+sha256 381f65d22c7dae3cd7ae502dd28d75b2a5279c29d659c54b8ef2b3fc4e77f4c9 aarch64-mbedtee-elf-14.2.0.tar.bz2
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-aarch64/toolchain-mbedtee-aarch64.mk buildroot/toolchain/toolchain-mbedtee-aarch64/toolchain-mbedtee-aarch64.mk
--- buildroot-ori/toolchain/toolchain-mbedtee-aarch64/toolchain-mbedtee-aarch64.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-aarch64/toolchain-mbedtee-aarch64.mk	2025-09-15 15:54:07.240754848 +0800
@@ -0,0 +1,29 @@
+################################################################################
+#
+# toolchain-mbedtee-aarch64
+#
+################################################################################
+
+TOOLCHAIN_MBEDTEE_AARCH64_VERSION = 15.2.0
+
+TOOLCHAIN_MBEDTEE_AARCH64_NAME = toolchain-mbedtee-aarch64
+TOOLCHAIN_MBEDTEE_AARCH64_INSTALL_DIR=$(HOST_DIR)/opt/$(TOOLCHAIN_MBEDTEE_AARCH64_NAME)
+TOOLCHAIN_MBEDTEE_AARCH64_BIN := $(TOOLCHAIN_MBEDTEE_AARCH64_INSTALL_DIR)/bin
+
+TOOLCHAIN_MBEDTEE_AARCH64_CROSS=$(TOOLCHAIN_MBEDTEE_AARCH64_BIN)/aarch64-mbedtee-elf-
+TOOLCHAIN_MBEDTEE_AARCH64_CC=$(TOOLCHAIN_MBEDTEE_AARCH64_CROSS)gcc
+TOOLCHAIN_MBEDTEE_AARCH64_CXX=$(TOOLCHAIN_MBEDTEE_AARCH64_CROSS)g++
+TOOLCHAIN_MBEDTEE_AARCH64_READELF=$(TOOLCHAIN_MBEDTEE_AARCH64_CROSS)readelf
+
+TOOLCHAIN_MBEDTEE_AARCH64_SITE = https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvYy9hZGU1YzFiOWU3MzhkYTRkL0VTSFRpUHhpZHQ1RWlBSDlkOFpZZ19RQnFvNUtKTE5Sd1lXQVdaVUVTeU5YLVE_ZT1RdUFjc2E
+TOOLCHAIN_MBEDTEE_AARCH64_SOURCE = aarch64-mbedtee-elf-$(TOOLCHAIN_MBEDTEE_AARCH64_VERSION).tar.bz2
+
+TOOLCHAIN_MBEDTEE_AARCH64_NO_FASTBUILD = y
+
+define TOOLCHAIN_MBEDTEE_AARCH64_EXTRACT_CMDS
+	mkdir -p $(TOOLCHAIN_MBEDTEE_AARCH64_INSTALL_DIR)
+	$(call suitable-extractor,.tar.bz2) $(DL_DIR)/$(TOOLCHAIN_MBEDTEE_AARCH64_NAME)/$(TOOLCHAIN_MBEDTEE_AARCH64_SOURCE) | \
+		$(TAR) --strip-components=1 --exclude='usr/lib/locale/*' -C $(TOOLCHAIN_MBEDTEE_AARCH64_INSTALL_DIR) $(TAR_OPTIONS) -
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-arm/Config.in buildroot/toolchain/toolchain-mbedtee-arm/Config.in
--- buildroot-ori/toolchain/toolchain-mbedtee-arm/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-arm/Config.in	2025-09-15 15:54:07.240754848 +0800
@@ -0,0 +1,7 @@
+config BR2_TOOLCHAIN_MBEDTEE_ARM
+	bool "MbedTEE Toolchain"
+	depends on BR2_arm
+	depends on BR2_ARM_CPU_ARMV7A
+	help
+	  ARMv7-A Tollchain with GCC
+
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-arm/--toolchain-mbedtee-arm.hash buildroot/toolchain/toolchain-mbedtee-arm/--toolchain-mbedtee-arm.hash
--- buildroot-ori/toolchain/toolchain-mbedtee-arm/--toolchain-mbedtee-arm.hash	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-arm/--toolchain-mbedtee-arm.hash	2025-09-15 15:54:07.240754848 +0800
@@ -0,0 +1,2 @@
+# Locally calculated
+sha256 d2cfcac5f9828d00c64be65e3a506eebb9b816203c91db07f936f316c6d4306e arm-mbedtee-eabi-14.2.0.tar.bz2
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-arm/toolchain-mbedtee-arm.mk buildroot/toolchain/toolchain-mbedtee-arm/toolchain-mbedtee-arm.mk
--- buildroot-ori/toolchain/toolchain-mbedtee-arm/toolchain-mbedtee-arm.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-arm/toolchain-mbedtee-arm.mk	2025-09-15 15:54:07.240754848 +0800
@@ -0,0 +1,29 @@
+################################################################################
+#
+# toolchain-mbedtee-arm
+#
+################################################################################
+
+TOOLCHAIN_MBEDTEE_ARM_VERSION = 15.2.0
+
+TOOLCHAIN_MBEDTEE_ARM_NAME = toolchain-mbedtee-arm
+TOOLCHAIN_MBEDTEE_ARM_INSTALL_DIR=$(HOST_DIR)/opt/$(TOOLCHAIN_MBEDTEE_ARM_NAME)
+TOOLCHAIN_MBEDTEE_ARM_BIN := $(TOOLCHAIN_MBEDTEE_ARM_INSTALL_DIR)/bin
+
+TOOLCHAIN_MBEDTEE_ARM_CROSS=$(TOOLCHAIN_MBEDTEE_ARM_BIN)/arm-mbedtee-eabi-
+TOOLCHAIN_MBEDTEE_ARM_CC=$(TOOLCHAIN_MBEDTEE_ARM_CROSS)gcc
+TOOLCHAIN_MBEDTEE_ARM_CXX=$(TOOLCHAIN_MBEDTEE_ARM_CROSS)g++
+TOOLCHAIN_MBEDTEE_ARM_READELF=$(TOOLCHAIN_MBEDTEE_ARM_CROSS)readelf
+
+TOOLCHAIN_MBEDTEE_ARM_SITE = https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvYy9hZGU1YzFiOWU3MzhkYTRkL0VYLU1aODd6a1JoTXRUOF85NjkybEhvQm5FbGdQU0pBenkwZ0g5R0tpVUFNMFE_ZT1LaGJ6SGg
+TOOLCHAIN_MBEDTEE_ARM_SOURCE = arm-mbedtee-eabi-$(TOOLCHAIN_MBEDTEE_ARM_VERSION).tar.bz2
+
+TOOLCHAIN_MBEDTEE_ARM_NO_FASTBUILD = y
+
+define TOOLCHAIN_MBEDTEE_ARM_EXTRACT_CMDS
+	mkdir -p $(TOOLCHAIN_MBEDTEE_ARM_INSTALL_DIR)
+	$(call suitable-extractor,.tar.bz2) $(DL_DIR)/$(TOOLCHAIN_MBEDTEE_ARM_NAME)/$(TOOLCHAIN_MBEDTEE_ARM_SOURCE) | \
+		$(TAR) --strip-components=1 --exclude='usr/lib/locale/*' -C $(TOOLCHAIN_MBEDTEE_ARM_INSTALL_DIR) $(TAR_OPTIONS) -
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-mips/Config.in buildroot/toolchain/toolchain-mbedtee-mips/Config.in
--- buildroot-ori/toolchain/toolchain-mbedtee-mips/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-mips/Config.in	2025-09-15 15:54:07.241755915 +0800
@@ -0,0 +1,6 @@
+config BR2_TOOLCHAIN_MBEDTEE_MIPS
+	bool "mbedtee MIPS32 Toolchain"
+	depends on BR2_mipsel
+	help
+	  MIPS32 Tollchain with GCC
+
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-mips/--toolchain-mbedtee-mips.hash buildroot/toolchain/toolchain-mbedtee-mips/--toolchain-mbedtee-mips.hash
--- buildroot-ori/toolchain/toolchain-mbedtee-mips/--toolchain-mbedtee-mips.hash	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-mips/--toolchain-mbedtee-mips.hash	2025-09-15 15:54:07.241755915 +0800
@@ -0,0 +1,2 @@
+# Locally calculated
+sha256 c9363dfa7df877471bbe892b78d33637439fdbbeb5c77db71e31730f5f6e438e mips-mbedtee-elf-14.2.0.tar.bz2
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-mips/toolchain-mbedtee-mips.mk buildroot/toolchain/toolchain-mbedtee-mips/toolchain-mbedtee-mips.mk
--- buildroot-ori/toolchain/toolchain-mbedtee-mips/toolchain-mbedtee-mips.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-mips/toolchain-mbedtee-mips.mk	2025-09-15 15:54:07.241755915 +0800
@@ -0,0 +1,29 @@
+################################################################################
+#
+# toolchain-mbedtee-mips
+#
+################################################################################
+
+TOOLCHAIN_MBEDTEE_MIPS_VERSION = 15.2.0
+
+TOOLCHAIN_MBEDTEE_MIPS_NAME = toolchain-mbedtee-mips
+TOOLCHAIN_MBEDTEE_MIPS_INSTALL_DIR=$(HOST_DIR)/opt/$(TOOLCHAIN_MBEDTEE_MIPS_NAME)
+TOOLCHAIN_MBEDTEE_MIPS_BIN := $(TOOLCHAIN_MBEDTEE_MIPS_INSTALL_DIR)/bin
+
+TOOLCHAIN_MBEDTEE_MIPS_CROSS=$(TOOLCHAIN_MBEDTEE_MIPS_BIN)/mips-mbedtee-elf-
+TOOLCHAIN_MBEDTEE_MIPS_CC=$(TOOLCHAIN_MBEDTEE_MIPS_CROSS)gcc
+TOOLCHAIN_MBEDTEE_MIPS_CXX=$(TOOLCHAIN_MBEDTEE_MIPS_CROSS)g++
+TOOLCHAIN_MBEDTEE_MIPS_READELF=$(TOOLCHAIN_MBEDTEE_MIPS_CROSS)readelf
+
+TOOLCHAIN_MBEDTEE_MIPS_SITE = https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvYy9hZGU1YzFiOWU3MzhkYTRkL0VYNVM1NUJDdldWS2t1bjNkUjg2QmFnQjNsejFXT3NaN2w3R0xwaU1LYmJwdkE_ZT1SS3V2bGo
+TOOLCHAIN_MBEDTEE_MIPS_SOURCE = mips-mbedtee-elf-$(TOOLCHAIN_MBEDTEE_MIPS_VERSION).tar.bz2
+
+TOOLCHAIN_MBEDTEE_MIPS_NO_FASTBUILD = y
+
+define TOOLCHAIN_MBEDTEE_MIPS_EXTRACT_CMDS
+	mkdir -p $(TOOLCHAIN_MBEDTEE_MIPS_INSTALL_DIR)
+	$(call suitable-extractor,.tar.bz2) $(DL_DIR)/$(TOOLCHAIN_MBEDTEE_MIPS_NAME)/$(TOOLCHAIN_MBEDTEE_MIPS_SOURCE) | \
+		$(TAR) --strip-components=1 --exclude='usr/lib/locale/*' -C $(TOOLCHAIN_MBEDTEE_MIPS_INSTALL_DIR) $(TAR_OPTIONS) -
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-riscv32/Config.in buildroot/toolchain/toolchain-mbedtee-riscv32/Config.in
--- buildroot-ori/toolchain/toolchain-mbedtee-riscv32/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-riscv32/Config.in	2025-09-15 15:54:07.242756982 +0800
@@ -0,0 +1,6 @@
+config BR2_TOOLCHAIN_MBEDTEE_RISCV32
+	bool "mbedtee riscv32 toolchain"
+	depends on BR2_riscv && BR2_RISCV_32
+	help
+	  RISCV32 Toolchain with GCC
+
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-riscv32/--toolchain-mbedtee-riscv32.hash buildroot/toolchain/toolchain-mbedtee-riscv32/--toolchain-mbedtee-riscv32.hash
--- buildroot-ori/toolchain/toolchain-mbedtee-riscv32/--toolchain-mbedtee-riscv32.hash	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-riscv32/--toolchain-mbedtee-riscv32.hash	2025-09-15 15:54:07.242756982 +0800
@@ -0,0 +1,2 @@
+# Locally calculated
+sha256 c9363dfa7df877471bbe892b78d33637439fdbbeb5c77db71e31730f5f6e438e riscv32-mbedtee-elf-14.2.0.tar.bz2
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-riscv32/toolchain-mbedtee-riscv32.mk buildroot/toolchain/toolchain-mbedtee-riscv32/toolchain-mbedtee-riscv32.mk
--- buildroot-ori/toolchain/toolchain-mbedtee-riscv32/toolchain-mbedtee-riscv32.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-riscv32/toolchain-mbedtee-riscv32.mk	2025-09-15 15:54:07.242756982 +0800
@@ -0,0 +1,29 @@
+################################################################################
+#
+# toolchain-mbedtee-riscv32
+#
+################################################################################
+
+TOOLCHAIN_MBEDTEE_RISCV32_VERSION = 15.2.0
+
+TOOLCHAIN_MBEDTEE_RISCV32_NAME = toolchain-mbedtee-riscv32
+TOOLCHAIN_MBEDTEE_RISCV32_INSTALL_DIR=$(HOST_DIR)/opt/$(TOOLCHAIN_MBEDTEE_RISCV32_NAME)
+TOOLCHAIN_MBEDTEE_RISCV32_BIN := $(TOOLCHAIN_MBEDTEE_RISCV32_INSTALL_DIR)/bin
+
+TOOLCHAIN_MBEDTEE_RISCV32_CROSS=$(TOOLCHAIN_MBEDTEE_RISCV32_BIN)/riscv32-mbedtee-elf-
+TOOLCHAIN_MBEDTEE_RISCV32_CC=$(TOOLCHAIN_MBEDTEE_RISCV32_CROSS)gcc
+TOOLCHAIN_MBEDTEE_RISCV32_CXX=$(TOOLCHAIN_MBEDTEE_RISCV32_CROSS)g++
+TOOLCHAIN_MBEDTEE_RISCV32_READELF=$(TOOLCHAIN_MBEDTEE_RISCV32_CROSS)readelf
+
+TOOLCHAIN_MBEDTEE_RISCV32_SITE = https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvYy9hZGU1YzFiOWU3MzhkYTRkL0VhSGZha2hleFpORHA5NkxvbXNkSUtnQkg0TkI4NkpVZVpfQ0pwdGR0MG5DWXc_ZT1LaTB1VWk
+TOOLCHAIN_MBEDTEE_RISCV32_SOURCE = riscv32-mbedtee-elf-$(TOOLCHAIN_MBEDTEE_RISCV32_VERSION).tar.bz2
+
+TOOLCHAIN_MBEDTEE_RISCV32_NO_FASTBUILD = y
+
+define TOOLCHAIN_MBEDTEE_RISCV32_EXTRACT_CMDS
+	mkdir -p $(TOOLCHAIN_MBEDTEE_RISCV32_INSTALL_DIR)
+	$(call suitable-extractor,.tar.bz2) $(DL_DIR)/$(TOOLCHAIN_MBEDTEE_RISCV32_NAME)/$(TOOLCHAIN_MBEDTEE_RISCV32_SOURCE) | \
+		$(TAR) --strip-components=1 --exclude='usr/lib/locale/*' -C $(TOOLCHAIN_MBEDTEE_RISCV32_INSTALL_DIR) $(TAR_OPTIONS) -
+endef
+
+$(eval $(generic-package))
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-riscv64/Config.in buildroot/toolchain/toolchain-mbedtee-riscv64/Config.in
--- buildroot-ori/toolchain/toolchain-mbedtee-riscv64/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-riscv64/Config.in	2025-09-15 15:54:07.242756982 +0800
@@ -0,0 +1,6 @@
+config BR2_TOOLCHAIN_MBEDTEE_RISCV64
+	bool "mbedtee riscv64 toolchain"
+	depends on BR2_riscv && BR2_RISCV_64
+	help
+	  RISCV64 Toolchain with GCC
+
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-riscv64/--toolchain-mbedtee-riscv64.hash buildroot/toolchain/toolchain-mbedtee-riscv64/--toolchain-mbedtee-riscv64.hash
--- buildroot-ori/toolchain/toolchain-mbedtee-riscv64/--toolchain-mbedtee-riscv64.hash	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-riscv64/--toolchain-mbedtee-riscv64.hash	2025-09-15 15:54:07.243758048 +0800
@@ -0,0 +1,2 @@
+# Locally calculated
+sha256 c9363dfa7df877471bbe892b78d33637439fdbbeb5c77db71e31730f5f6e438e riscv64-mbedtee-elf-14.2.0.tar.bz2
diff -uprN '--exclude=.*' '--exclude=output' '--exclude=dl' '--exclude=local.mk' buildroot-ori/toolchain/toolchain-mbedtee-riscv64/toolchain-mbedtee-riscv64.mk buildroot/toolchain/toolchain-mbedtee-riscv64/toolchain-mbedtee-riscv64.mk
--- buildroot-ori/toolchain/toolchain-mbedtee-riscv64/toolchain-mbedtee-riscv64.mk	1970-01-01 08:00:00.000000000 +0800
+++ buildroot/toolchain/toolchain-mbedtee-riscv64/toolchain-mbedtee-riscv64.mk	2025-09-15 15:54:07.243758048 +0800
@@ -0,0 +1,29 @@
+################################################################################
+#
+# toolchain-mbedtee-riscv64
+#
+################################################################################
+
+TOOLCHAIN_MBEDTEE_RISCV64_VERSION = 15.2.0
+
+TOOLCHAIN_MBEDTEE_RISCV64_NAME = toolchain-mbedtee-riscv64
+TOOLCHAIN_MBEDTEE_RISCV64_INSTALL_DIR=$(HOST_DIR)/opt/$(TOOLCHAIN_MBEDTEE_RISCV64_NAME)
+TOOLCHAIN_MBEDTEE_RISCV64_BIN := $(TOOLCHAIN_MBEDTEE_RISCV64_INSTALL_DIR)/bin
+
+TOOLCHAIN_MBEDTEE_RISCV64_CROSS=$(TOOLCHAIN_MBEDTEE_RISCV64_BIN)/riscv64-mbedtee-elf-
+TOOLCHAIN_MBEDTEE_RISCV64_CC=$(TOOLCHAIN_MBEDTEE_RISCV64_CROSS)gcc
+TOOLCHAIN_MBEDTEE_RISCV64_CXX=$(TOOLCHAIN_MBEDTEE_RISCV64_CROSS)g++
+TOOLCHAIN_MBEDTEE_RISCV64_READELF=$(TOOLCHAIN_MBEDTEE_RISCV64_CROSS)readelf
+
+TOOLCHAIN_MBEDTEE_RISCV64_SITE = https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvYy9hZGU1YzFiOWU3MzhkYTRkL0VieEFVcW5ZVi10UHF1M19pNGo5TWVnQmxVUDREMWlMOXRMWUFaeS1NaEVOZHc_ZT1TNms1a1k
+TOOLCHAIN_MBEDTEE_RISCV64_SOURCE = riscv64-mbedtee-elf-$(TOOLCHAIN_MBEDTEE_RISCV64_VERSION).tar.bz2
+
+TOOLCHAIN_MBEDTEE_RISCV64_NO_FASTBUILD = y
+
+define TOOLCHAIN_MBEDTEE_RISCV64_EXTRACT_CMDS
+	mkdir -p $(TOOLCHAIN_MBEDTEE_RISCV64_INSTALL_DIR)
+	$(call suitable-extractor,.tar.bz2) $(DL_DIR)/$(TOOLCHAIN_MBEDTEE_RISCV64_NAME)/$(TOOLCHAIN_MBEDTEE_RISCV64_SOURCE) | \
+		$(TAR) --strip-components=1 --exclude='usr/lib/locale/*' -C $(TOOLCHAIN_MBEDTEE_RISCV64_INSTALL_DIR) $(TAR_OPTIONS) -
+endef
+
+$(eval $(generic-package))
